colnames(rij) <- cc									# STEP gives the column names corresponding to the coefficients that are kept
switch(Meth,
"Fo" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(intercept_only, direction='forward', scope=formula(all), trace=0)},	# Forward
"Ba" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(all, direction='backward', scope=formula(all), trace=0)},				# Backward
"Bo" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(intercept_only, direction='both', scope=formula(all), trace=0)},		# Both
)
ll  	<- length(forward$coefficients)				# Number of coefficients kept by step
nn		<- names(forward$coefficients)				# Name of these coefficients
rij[1, ]	<- 0
if (ll >= 2) {
for (i in 2:ll) {								# nn[1] = "(Intercept)"
rij[1, nn[i]] <- forward$coefficients[nn[i]]
}
}
if (Verbose) {
cat ("fSTEP  ll ", ll, " nn ", nn, " rij ", rij, "\n")
}
return(rij[1, ])
},		# expr
error = function (e) {
message ("Error detected in STEP method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fSTEP
#' Computes the "Connectivity Matrix" using Random Forest Method (library randomForest)
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param seqLetters	A sequence of lower case letters "a", "b" .... used to name the columns
#'@param nbN		Number of nodes
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise  (vector, length = nbN-1)
#'
fRForest	<- function (MatU, MatY, seqLetters, nbN) {
tryCatch (
expr = {
rL 			<- vector(length=nbN-1)					# Result of Random Forest method
nbLmin		<- 80									# minimum number of rows to use Random Forest method
MatA		<- cbind(MatY, MatU)
nr			<- nrow(MatA)
nrep		<- round(nbLmin/nr)
MatB		<- MatA
if (nrep > 1) {
for (i in 1:nrep) {									# to have enough rows
MatB	<- rbind(MatB, MatA)
}
}
colnames(MatB)	<- c("Y", seqLetters)
rf			<- randomForest(Y ~ ., data=MatB, importance=TRUE)
rL			<- importance(rf)[,1]/sum(abs(importance(rf)[,1]))
return (rL)
},		# expr
error = function (e) {
message ("Error detected in Random Forest method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fRForest
#' Computes a sequence of letters : "a", "b", "c", ...., "z", "aa", "ab", .... , "az", "ba", "bb" etc ....
#'
#'@param	n		The number of elements of the sequence
#'
#'
#' @return			A vector, length n, containing the sequence of letters
#'
sequence_letters <- function(n) {
tryCatch (
expr = {
seq <- character(n)
letters <- c(letters, "")
for (i in 1:n) {
indices <- c()
k <- i - 1
while (k >= 0) {
indices <- c((k %% 26) + 1, indices)
k <- k %/% 26 - 1
}
seq[i] <- paste0(letters[indices], collapse = "")
}
return(seq)
},		# expr
error = function (e) {
message ("Error detected in sequence_letters function!")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# sequence_letters
#' Computes a squared value
#'
#'@param	x		The value to square (may be a vector)
#'
#'
#' @return			A vector, with the values squared
#'
fcarre	= function(x) {x^2}
MExt2		<- matrix(c(12,18,7,21, 1,1,1,1, 4,9,6,12,  12,18,7,21, 3,1,6,9, 4,9,6,12), nrow=4)
Pert2		<- c("P1->N1", "Base", "P2->N2", "P'1->N3", "Base", "P'2->N4")
Res1		<- MRARegress (MExt1, Relative=FALSE)$r
dimnames(Res1)	<- NULL
Res2		<- MRARegress (MExt2, Pert2, Relative=FALSE)$r
dimnames(Res2)	<- NULL
test_that("The basal column is not the first one", {
expect_equal (Res1, Res2, tolerance=1E-4)
})
MExt2		<- matrix(c(12,18,7,21, 1,1,1,1, 4,9,6,12,  12,18,7,21, 3,1,6,9, 4,9,6,11), nrow=4)
Pert2		<- c("P1->N1", "Base", "P2->N2", "P'1->N3", "Base", "P'2->N4")
Res1		<- MRARegress (MExt1, Relative=FALSE)$r
dimnames(Res1)	<- NULL
Res2		<- MRARegress (MExt2, Pert2, Relative=FALSE)$r
dimnames(Res2)	<- NULL
test_that("The basal column is not the first one", {
expect_equal (Res1, Res2, tolerance=1E-4)
})
MExt2		<- matrix(c(12,18,7,21, 1,1,1,1, 4,9,6,12,  12,18,7,21, 3,1,6,9, 4,9,6,11), nrow=4)
Pert2		<- c("P1->N1", "Base", "P2->N2", "P'1->N3", "Base", "P'2->N4")
Res1		<- MRARegress (MExt1, Relative=FALSE)$r
Res1
MExt2		<- matrix(c(12,18,7,21, 1,1,1,1, 4,9,6,12,  12,18,7,21, 3,1,6,8, 4,9,6,12), nrow=4)
Pert2		<- c("P1->N1", "Base", "P2->N2", "P'1->N3", "Base", "P'2->N4")
Res1		<- MRARegress (MExt1, Relative=FALSE)$r
dimnames(Res1)	<- NULL
Res2		<- MRARegress (MExt2, Pert2, Relative=FALSE)$r
MExt2		<- matrix(c(12,18,7,21, 1,1,1,1, 4,9,6,12,  12,18,7,21, 3,1,6,8, 4,9,6,13), nrow=4)
Pert2		<- c("P1->N1", "Base", "P2->N2", "P'1->N3", "Base", "P'2->N4")
Res1		<- MRARegress (MExt1, Relative=FALSE)$r
dimnames(Res1)	<- NULL
Res2		<- MRARegress (MExt2, Pert2, Relative=FALSE)$r
MExt2		<- matrix(c(12,18,7,21, 1,1,1,1, 4,9,6,12,  12,18,7,21, 3,1,6,8, 4,9,7,13), nrow=4)
Pert2		<- c("P1->N1", "Base", "P2->N2", "P'1->N3", "Base", "P'2->N4")
Res1		<- MRARegress (MExt1, Relative=FALSE)$r
dimnames(Res1)	<- NULL
Res2		<- MRARegress (MExt2, Pert2, Relative=FALSE)$r
MExt1		<- matrix(c(1,1,1,1,   12,18,7,21,  4,9,6,12, 10,18,2,13, 2,9,1,4), nrow=4)
MExt2		<- matrix(c(12,18,7,21,  4,9,6,12, 10,18,2,13, 1,1,1,1,   2,9,1,4), nrow=4)
Pert2		<- c("P1->N1", "P2->N2", "P3->N3", "Base", "P4->N4")
Res1		<- MRARegress (MExt1, Relative=FALSE)$r
dimnames(Res1)	<- NULL
Res2		<- MRARegress (MExt2, Pert2, Relative=FALSE)$r
dimnames(Res2)	<- NULL
test_that("The basal column is not the first one", {
expect_equal (Res1, Res2, tolerance=1E-4)
})
st 	<-c (0.1, 0.1, 0.1)
F3  <- function(P,X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
# X contains the expression levels of pRaF, ppMEK, ppERK respectively.
Perturbs			<- c(0.2, 0.9, 0.99)
nbPert				<- length(Perturbs)
P0					<- c(1, 1, 1)
Exp_3_02_09_099 	<- MExp (3, Perturbs, P0, F3, st)
load("C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRAregress\\data\\ResO2_3.rda")		#	ResO2_3
test_that("Order2 - 3 Genes network", {
expect_equal (MRARegress(Exp_3_02_09_099$Exp, Exp_3_02_09_099$Pert, Method="Order2", Relative=FALSE)$Order2, ResO2_3, tolerance=1E-4)
})
nbN					<- 3												# Three nodes
nbReplic			<- 2												# Two replicates
XMesNPMoy			<- mean(abs(Exp_3_02_09_099$Exp[1, ]))				# Mean of basal values
Sd					<- 0.01*XMesNPMoy									# Standard deviation of the noise to add
MExp_				<- matrix(0, nrow=nbN, ncol=1)
set.seed(12345)
MExp_[ ,1]			<-	Exp_3_02_09_099$Exp[ ,1]
Pert_				<- c("Base")
for (iRep in 1:nbReplic) {
MExp_3_2	<- Exp_3_02_09_099$Exp + rnorm(nbN*(nbN*nbPert+1), mean=0, sd=Sd)
MExp_		<- cbind(MExp_, MExp_3_2[ ,2:(nbPert*nbN+1)])
Pert_		<- c(Pert_, Exp_3_02_09_099$Pert[2:(nbPert*nbN+1)])
}
Res_		<- MRARegress(MExp_, Pert_, Relative=FALSE)
Res_$ANOVA[[1]]["SSR","F/M"]
test_that("Order1 - 3 Genes network, 2 replicates - ANOVA1", {
expect_equal (Res_$ANOVA[[1]]["SSR","F/M"], 26831.38, tolerance=1E-4)
})
Res_$ANOVA[[1]]["LOF","F/M"]
test_that("Order1 - 3 Genes network, 2 replicates - ANOVA1", {
expect_equal (Res_$ANOVA[[1]]["SSR","F/M"], 26831.38, tolerance=1E-4)
})
test_that("Order1 - 3 Genes network, 2 replicates - ANOVA2", {
expect_equal (Res_$ANOVA[[1]]["LOF","F/M"], 25.86601, tolerance=1E-4)
})
KA14 <- 1.6			# Michaelis constants (nM)
KI12 <- 0.5
KA24 <- 1.6
KA32 <- 1.5
KI31 <- 0.7
KA43 <- 0.15
KD1	 <- 30
KD2	 <- 60
KD3	 <- 10
KD4	 <- 50
A14	 <- 4			# Dimensionless coefficient
n12	 <- 1
n14	 <- 2
A24	 <- 4
n24	 <- 2
A32	 <- 5
n31	 <- 1
n32	 <- 2
A43	 <- 2
n43	 <- 2
VS1	 <- 5			# Maximum enzyme level (nM.s-1) : "Untangling the wires ... "
VS2	 <- 3.5
VS3	 <- 3
VS4	 <- 4
VD1	 <- 200
VD2	 <- 500
VD3	 <- 150
VD4	 <- 500
VS1	 <- 1			# Maximum enzyme level (nM.Hr-1) : "Inferring dynamic architecture ... "
VS2	 <- 0.7
VS3	 <- 0.6
VS4	 <- 0.8
VD1	 <- 40
VD2	 <- 100
VD3	 <- 30
VD4	 <- 100
F4  <- function(P,X)
c(F1 = (P[1]*(1+A14*(X[4]/KA14)^n14)) / ((1+(X[4]/KA14)^n14)*(1+(X[2]/KI12)^n12)) - (VD1*X[1]) / (KD1+X[1]),
F2 = (P[2]*(1+A24*(X[4]/KA24)^n24)) /  (1+(X[4]/KA24)^n24) - (VD2*X[2]) / (KD2+X[2]),
F3 = (P[3]*(1+A32*(X[2]/KA32)^n32)) / ((1+(X[2]/KA32)^n32)*(1+(X[1]/KI31)^n31)) - (VD3*X[3]) / (KD3+X[3]),
F4 = (P[4]*(1+A43*(X[3]/KA43)^n43)) /  (1+(X[3]/KA43)^n43) - (VD4*X[4]) / (KD4+X[4]))
nbN			<- 4
Perturbs	<- c(0.2, 0.9, 0.99)
P0			<- c(VS1, VS2, VS3, VS4)
st 			<- c (0.1, 0.1, 0.1, 0.1)
Exp_ 		<- MExp (nbN, Perturbs, P0, F4, st)
load("C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRAregress\\data\\ResO2_4.rda")		#	ResO2_4
Res_4_2		<-	MRARegress(Exp_$Exp, Exp_$Pert, Method="Order2", Relative=FALSE)
test_that("Order2 - 4 Genes network", {
expect_equal (Res_4_2$Order2, ResO2_4, tolerance=1E-4)
})
Res_4_1		<-	MRARegress(Exp_$Exp, Exp_$Pert, Relative=FALSE)
Res_4_1$ANOVA[[1]]["SSR","F/M"]
Res_4_1		<-	MRARegress(Exp_$Exp, Exp_$Pert, Relative=FALSE)
test_that("Order1 - 4 Genes network, no replicate - ANOVA", {
expect_equal (Res_4_1$ANOVA[[1]]["SSR","F/M"], 1029.353, tolerance=1E-4)
})
KC1	 <- 1			# Catalytic rate (s-1)
KC2	 <- 15
KC5	 <- 1
KC6	 <- 15
KC9	 <- 1
KC10 <- 15
K11	 <- 300			# Michaelis constants (nM)
K12	 <- 20
K31	 <- 22
K32	 <- 18
K33	 <- 80
K51	 <- 300
K52	 <- 20
K71	 <- 22
K72	 <- 18
K73	 <- 80
K91	 <- 300
K92	 <- 20
K111 <- 22
K112 <- 18
K113 <- 80
Ki	 <- 100
Kmp	 <- 100
A	 <- 5			# Dimensionless coefficient
V3	 <- 18.8		# Maximum enzyme level (nM.s-1)
V4	 <- 16.4
V7	 <- 18.8
V8	 <- 16.4
V11	 <- 8.4
V12	 <- 7.3
MKKK0	<- 200		# X1+X7+X2	: total protein MKKK concentration
MKK0	<- 180		# X3+X8+X4	: total protein MKK  concentration
MAPK0	<- 360		# X5+X9+X6	: total protein MAPK concentration
U		<- 20
F6 	<- function(P,X)
c(F1 = (KC1*U*X[1]) 	/ ((K11+X[1]+(MKKK0-X[1]-X[2])*K11/K12)*(1+X[6]/Ki)) - ((P[1]*(MKKK0-X[1]-X[2]))  / (K31+X[2]+(MKKK0-X[1]-X[2])*K31/K32+X[1]*K31/K33)),
F2 = (KC2*U*(MKKK0-X[1]-X[2]))    / ((K11+X[1]+(MKKK0-X[1]-X[2])*K11/K12)*(1+X[6]/Ki)) - ((P[2]*X[2])  / (K31+X[2]+(MKKK0-X[1]-X[2])*K31/K32+X[1]*K31/K33)),
F3 = (KC5*X[3]*X[2]) / (K51+X[3]+(MKK0-X[3]-X[4])*K51/K52) - ((P[3]*(MKK0-X[3]-X[4])*(1+A*X[6]/Kmp))   / ((K71+X[4]+(MKK0-X[3]-X[4])*K71/K72+X[3]*K71/K73)*(1+X[6]/Kmp))),
F4 = (KC6*(MKK0-X[3]-X[4])*X[2])  / (K51+X[3]+(MKK0-X[3]-X[4])*K51/K52) - ((P[4]*X[4]*(1+A*X[6]/Kmp))  / ((K71+X[4]+(MKK0-X[3]-X[4])*K71/K72+X[3]*K71/K73)*(1+X[6]/Kmp))),
F5 = (KC9*X[4]*X[5]) / (K91+X[5]+(MAPK0-X[5]-X[6])*K91/K92) - ((P[5]*(MAPK0-X[5]-X[6])) / (K111+X[6]+(MAPK0-X[5]-X[6])*K111/K112+X[5]*K111/K113)),
F6 = (KC10*X[4]*(MAPK0-X[5]-X[6]))/ (K91+X[5]*(MAPK0-X[5]-X[6])*K91/K92) - ((P[6]*X[6]) / (K111+X[6]+(MAPK0-X[5]-X[6])*K111/K112+X[5]*K111/K113)))
nbN			<- 6
Perturbs	<- c(0.2, 0.5, 0.9, 0.99, 1.5)
P0			<- c(V4, V3, V8, V7, V12, V11)
st			<- c(130,45,52,105,135,27)
Exp_		<-	MExp (nbN, Perturbs, P0, F6, st)
load("C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRAregress\\data\\ResO2_6.rda")		#	ResO2_6
Res_6_2		<-	MRARegress(Exp_$Exp, Exp_$Pert, Method="Order2", Relative=FALSE)
test_that("Order2 - 6 MAP kinases network", {
expect_equal (Res_6_2$Order2, ResO2_6, tolerance=1E-4)
})
Res_6_1		<-	MRARegress(Exp_$Exp, Exp_$Pert, Relative=FALSE)
Res_6_1$ANOVA[[1]]["SSR","F/M"]
Res_6_1		<-	MRARegress(Exp_$Exp, Exp_$Pert, Relative=FALSE)
test_that("Order1 - 6 Genes network, no replicate - ANOVA", {
expect_equal (Res_6_1$ANOVA[[1]]["SSR","F/M"], 76431.25, tolerance=1E-4)
})
covr <- package_coverage(path=".")
library(covr)
covr <- package_coverage(path=".")
covr
covr <- package_coverage(path="C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRARegress")
covr
library(DT)
library(htmltools)
covr <- package_coverage(path=".")
covr
library(MRARegress)
detach("package:MRARegress", unload = TRUE)
covr <- package_coverage(path=".")
covr
covr <- package_coverage(path=".")
covr
covr <- package_coverage()
covr
covr <- package_coverage(path="C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRARegress")
covr
covr <- package_coverage(path="C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRARegress\\R")
covr
?package_coverage
covr <- package_coverage(path=".", type="all")
covr
report(covr)
covr <- package_coverage(path=".", type="tests")
covr
covr <- package_coverage(path=".", type="examples")
covr
covr <- package_coverage(path=".", type="vignettes")
covr
report(covr)
covr <- package_coverage(path=".", type="tests")
covr
library(stringr)
covr <- package_coverage(path=".", type="tests")
covr
covr <- package_coverage(path="C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages")
covr <- package_coverage(path="C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRARegress")
covr
covr <- package_coverage(path="C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRARegress")
covr
covr <- package_coverage(path="C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRARegress")
covr
library(MRARegress)
covr <- package_coverage(path=".", type="tests")
detach("package:MRARegress", unload = TRUE)
covr <- package_coverage(path=".", type="tests")
covr
covr <- covr::package_coverage(path=".", type="tests")
covr
covr <- covr::package_coverage(path=".", quiet=FALSE, clean=FALSE)
tempdir()
library(MRARegress)
detach("package:MRARegress", unload = TRUE)
library(covr)
covr <- package_coverage(path=".", quiet=FALSE, clean=FALSE)
tempdir()
covr
report(covr)
library(MRARegress)
detach("package:MRARegress", unload = TRUE)
library(covr)
covr <- package_coverage(path=".", clean=FALSE, quiet=FALSE)
covr
tempdir()
covr <- package_coverage(path=".")
library(covr)
covr <- package_coverage(path=".")
covr
dirtemp
dirtemp()
tempdir
tempdir()
covr <- package_coverage(path=".", clean=FALSE, quiet=FALSE)
covr
tempdir()
view(Covr)
View(Covr)
View(covr)
covr[["rCI.R:155:4:155:29:25:52:4389:4389"]][["srcref"]]
covr[["rCI.R:194:5:194:52:33:84:4428:4428"]][["srcref"]]
report(covr)
view(covr)
View(covr)
tempdir()
library(covr)
covr <- package_coverage(path=".", clean=FALSE, quiet=FALSE)
report(covr)
report(covr)
View(covr)
tempdir()
covr <- package_coverage(path=".")
library(covr)
covr <- package_coverage(path=".")
report(covr)
library(MRARegress)
library(covr)
detach("package:MRARegress", unload = TRUE)
covr <- package_coverage(path=".")
report(covr)
report(covr)
library("MRARegress")
library("testthat")
MatExp <- matrix(c(1:12), nrow=3)
MRARegress(MatExp)$r
MatExp	<- matrix(c(1,2,3, 11,21,31, 12,22,32, 13,23,33),nrow=3)
Ret	<- MRARegress (MatExp, Relative=FALSE)
RetDG	<- DrawGraph (Ret)
test_that("Simple network", {
+     expect_equal (RetDG$Variables[[2]], 3, tolerance=1E-4)			# 3 nodes (DrawGraph did well)
+ })
test_that("Simple network", {
+     expect_equal (RetDG$Variables[[2]], 3, tolerance=1E-4)			# 3 nodes (DrawGraph succeeded)
+ })
test_that("Simple network", {
expect_equal (RetDG$Variables[[2]], 3, tolerance=1E-4)			# 3 nodes (DrawGraph succeeded)
})
Ret$r
devtools::load_all(".")
covr <- package_coverage(path=".", clean=FALSE, quiet=FALSE)
library(covr)
covr <- package_coverage(path=".", clean=FALSE, quiet=FALSE)
library(MRARegress)
detach("package:MRARegress", unload = TRUE)
covr <- package_coverage(path=".", clean=FALSE, quiet=FALSE)
report(covr)
View(covr)
tempdir()
devtools::load_all(".")
library(MRARegress)
library(covr)
detach("package:MRARegress", unload = TRUE)
covr <- package_coverage(path=".")
report(covr)
covr <- package_coverage(path=".", quiet=FALSE, clean=FALSE)
report(covr)
library(MRARegress)
library(covr)
detach("package:MRARegress", unload = TRUE)
covr <- package_coverage(path=".")
report(covr)
library(MRARegress)
library(MRARegress)
library(MRARegress)
library(covr)
detach("package:MRARegress", unload = TRUE)
covr <- package_coverage(path=".")	# Il faut 'détacher' le package MRARegress d'abord
report(covr)
covr	<-	file_coverage("MRARegress.R", "test_MRARegress.R")
covr	<-	file_coverage("R/MRARegress.R", "tests/testthat/test_MRARegress.R")
library(testthat)
covr	<-	file_coverage("R/MRARegress.R", "tests/testthat/test_MRARegress.R")
library(glmnet)
covr
covr	<-	file_coverage("R/MRARegress.R", "tests/testthat/test_MRARegress.R")
library(testthat)
library(stringr)
library(glmnet)
library(minet)
library(randomforest)
library(testthat)
library(stringr)
library(glmnet)
library(minet)
library(randomForest)
library(CVXR)
library(broom)
covr	<-	file_coverage("R/MRARegress.R", "tests/testthat/test_MRARegress.R")
library(testthat)
library(stringr)
library(glmnet)
library(minet)
library(randomForest)
library(CVXR)
library(broom)
library(stats)
library(dplyr)
library(magrittr)
library(rootSolve)
covr	<-	file_coverage("R/MRARegress.R", "tests/testthat/test_MRARegress.R")
library(MRARegress)
library(testthat)
library(stringr)
library(glmnet)
library(minet)
library(randomForest)
library(CVXR)
library(broom)
library(stats)
library(dplyr)
library(magrittr)
library(rootSolve)
covr	<-	file_coverage("R/MRARegress.R", "tests/testthat/test_MRARegress.R")
covr
covr
report(covr)
View(covr)
detach("package:MRARegress", unload = TRUE)
covr	<-	package_coverage(path=".")
covr
report(covr)
