nn		<- names(forward$coefficients)				# Name of these coefficients
rij[1, ]	<- 0
if (ll >= 2) {
for (i in 2:ll) {								# nn[1] = "(Intercept)"
rij[1, nn[i]] <- forward$coefficients[nn[i]]
}
}
if (Verbose) {
cat (" ll ", ll, " nn ", nn, " rij ", rij, "\n")
}
return(rij[1, ])
},		# expr
error = function (e) {
message ("Error detected in STEP method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fSTEP
#' Computes the "Connectivity Matrix" using Random Forest Method (library randomForest)
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param seqLetters	A sequence of lower case letters "a", "b" .... used to name the columns
#'@param nbN		Number of nodes
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise  (vector, length = nbN-1)
#'
fRForest	<- function (MatU, MatY, seqLetters, nbN) {
tryCatch (
expr = {
rL 			<- vector(length=nbN-1)					# Result of Random Forest method
nbLmin		<- 80									# minimum number of rows to use Random Forest method
MatA		<- cbind(MatY, MatU)
nr			<- nrow(MatA)
nrep		<- round(nbLmin/nr)
MatB		<- MatA
for (i in 1:nrep) {									# to have enough rows
MatB	<- rbind(MatB, MatA)
}
colnames(MatB)	<- c("Y", seqLetters)
rf			<- randomForest(Y ~ ., data=MatB, importance=TRUE)
rL			<- importance(rf)[,1]/sum(importance(rf)[,1])
return (rL)
},		# expr
error = function (e) {
message ("Error detected in Random Forest method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fRForest
#' Computes a sequence of letters : "a", "b", "c", ...., "z", "aa", "ab", .... , "az", "ba", "bb" etc ....
#'
#'@param	n		The number of elements of the sequence
#'
#'
#' @return			A vector, length n, containing the sequence of letters
#'
sequence_letters <- function(n) {
tryCatch (
expr = {
seq <- character(n)
letters <- c(letters, "")
for (i in 1:n) {
indices <- c()
k <- i - 1
while (k >= 0) {
indices <- c((k %% 26) + 1, indices)
k <- k %/% 26 - 1
}
seq[i] <- paste0(letters[indices], collapse = "")
}
return(seq)
},		# expr
error = function (e) {
message ("Error detected in sequence_letters function!")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# sequence_letters
#' Computes a squared value
#'
#'@param	x		The value to square (may be a vector)
#'
#'
#' @return			A vector, with the values squared
#'
fcarre	= function(x) {x^2}
test_that("Order1 - Thomaseth 3 nodes network Plan Expé Patrice", {
expect_equal (MRARegress(MExpPat_10, MapExper=ExperPat, Relative=FALSE)$r, Pat3nds_O1, tolerance=1E-2)
})
test_that("Order2 - Thomaseth 3 nodes network Plan Expé Patrice", {
expect_equal (MRARegress(MExpPat_10, MapExper=ExperPat, Method="Order2", Relative=FALSE)$r, Pat3nds_O1, tolerance=1E-3)
})
test_that("Order2 - Thomaseth 3 nodes network Plan Expé Patrice", {
expect_equal (MRARegress(MExpPat_10, MapExper=ExperPat, Method="Order2", Relative=FALSE)$Order2, Pat3nds_O2, tolerance=1E-4)
})
library(MRARegress)
library(MRARegress)
detach("package:MRARegress", unload = TRUE)
covr <- package_coverage(path=".")
library(covr)
covr <- package_coverage(path=".")
report(covr)
devtools::install_github("J-P-Borg/MRARegress")
load("C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRAregress\\data\\Pat3nds_O1.rda")		# Pat3nds_O1
load("C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRAregress\\data\\Pat3nds_O2.rda")		# Pat3nds_O2
MatExpJP_3	<- matrix(c(2.133728, 6.819618, 7.235918,   2.132878, 6.817047, 7.233394,  2.134409, 6.815775, 7.232144,  2.134481, 6.821894, 7.231744), nrow=3)
test_that("Order1 - Thomaseth 3 nodes network", {
expect_equal (MRARegress(MatExpJP_3, Relative=FALSE)$r, Pat3nds_O1, tolerance=1E-4)
})
library(testthat)
load("C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRAregress\\data\\Pat3nds_O1.rda")		# Pat3nds_O1
load("C:\\Users\\jean-pierre.borg\\IRCM\\These\\Recherche\\Packages\\MRAregress\\data\\Pat3nds_O2.rda")		# Pat3nds_O2
MatExpJP_3	<- matrix(c(2.133728, 6.819618, 7.235918,   2.132878, 6.817047, 7.233394,  2.134409, 6.815775, 7.232144,  2.134481, 6.821894, 7.231744), nrow=3)
test_that("Order1 - Thomaseth 3 nodes network", {
expect_equal (MRARegress(MatExpJP_3, Relative=FALSE)$r, Pat3nds_O1, tolerance=1E-4)
})
devtools::install_github("J-P-Borg/MRARegress")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
devtools::install_github("J-P-Borg/MRARegress")
?rlang
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
library(MRARegress)
Perturbs	<- c(0.2, 0.9, 0.99)
P0 			<- c(1, 1, 1)					# Valeur des paramètres
st 			<-c (0.1, 0.1, 0.1)
Perturbs<- c(0.99999)
MExp_3 	<-  MExp (nbN, Perturbs, P0, F, st)$Exp
nbN=3
MExp_3 	<-  MExp (nbN, Perturbs, P0, F, st)$Exp
F <- function(P,X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
#	où X représente les niveaux d'expression de pRaF, ppMEK, ppERK respectivement.
MExp_3 	<-  MExp (nbN, Perturbs, P0, F, st)$Exp
Pert_3  	<-  MExp (nbN, Perturbs, P0, F, st)$Pert
MRARegress(MExp_3, Pert_3, Relative=FALSE)$r
nbN			<-	3					# Nombre de noeuds
F3 <- function(X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
#	où X représente les niveaux d'expression de pRaF, ppMEK, ppERK respectivement.
st 			<- c(0.1, 0.1, 0.1)		# Point de départ de la recherche d'optimum. De ce point, on converge vers la solution.
P0 			<- c(1, 1, 1)			# Valeur intiale des paramètres
Perturbs	<- c(0.99)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
nbN			<-	3					# Nombre de noeuds
F3 <- function(P,X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
#	où X représente les niveaux d'expression de pRaF, ppMEK, ppERK respectivement.
st 			<- c(0.1, 0.1, 0.1)		# Point de départ de la recherche d'optimum. De ce point, on converge vers la solution.
P0 			<- c(1, 1, 1)			# Valeur intiale des paramètres
Perturbs	<- c(0.99)				# Une seule perturbation : -1%
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MRARegress (MExp_$Exp)$r
P0 		<- c(1, 1, 1)			# Valeur des paramètres
st 		<- c (0.1, 0.1, 0.1)
Perturbs	<- c(0.99999)
F <- function(P,X)
+     c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
+       F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
P0 		<- c(1, 1, 1)		# Valeur initiale des paramètres
Perturbs	<- c(0.99)		# Une seule perturbation : -1%
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MRARegress (MExp_$Exp, Relative=FALSE)$r
Perturbs	<- c(1.01)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MRARegress (MExp_$Exp, Relative=FALSE)$r
Perturbs	<- c(0.9)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MRARegress (MExp_$Exp, Relative=FALSE)$r
Perturbs	<- c(1.1)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MRARegress (MExp_$Exp, Relative=FALSE)$r
Perturbs	<- c(0.2)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MRARegress (MExp_$Exp, Relative=FALSE)$r
Perturbs	<- c(1.8)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MRARegress (MExp_$Exp, Relative=FALSE)$r
Perturbs	<- c(3.0)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MRARegress (MExp_$Exp, Relative=FALSE)$r
Perturbs	<- c(0.5)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MExp_$Exp
Perturbs	<- c(0.1)
MExp_		<- MExp(nbN, Perturbs, P0, F3, st)
MExp_$Exp
P0
st
F31 <- function(P,X)
c(F1 = P[1]*X[1],
F2 = P[2]*X[2],
F3 = P[3]*X[3])
Perturbs	<- c(0.1)
MExp_		<- MExp(nbN, Perturbs, P0, F31, st)
MExp_$Exp
Perturbs	<- c(0.5)
MExp_		<- MExp(nbN, Perturbs, P0, F31, st)
MExp_$Exp
MExp2	<- function (nbN, MapExper, Perturb, P0, func, st) {
#	nbP			<- length(Perturbs)
nbP			<- dim(MapExper)[2]							# Number of perturbations
MatExp		<- matrix (0, nrow=nbN, ncol=nbN*nbP+1)
Nom			<- vector(length=nbN*nbP+1)
F <- function(X) {return (func(P,X))}
P		<- P0
MatExp[ ,1]	<- (multiroot (f=F, start= st))$root
for (iPert in 1:nbP) {
#		Perturb	<- Perturbs[iPert]		# Perturb compris entre -1 et +1 ???
P	<- P0
for (iPar in 1:nbN) {
P[iPar]		<- P[iPar]*(1+Perturb*MapExper[iPar,iPert])
}
cat("iPert",iPert, "P \n")
print(P)
MatExp[ ,iPert+1]	<- (multiroot (f=F, start= st))$root
}
Nom[1]	<- "Base"
#	ind		<- 2
for (iPert in 1:nbP) {
#		for (iNode in 1:nbN) {
#			val	<- paste("Q", iNode, letters[iPert], "->N", iNode, sep="")		# valid up to 26 perturbs. otherwise, use "sequence_letters" in MRARegress
Nom[iPert+1]	<- paste("Q", letters[iPert],  sep="")		# valid up to 26 perturbs. otherwise, use "sequence_letters" in MRARegress
#			ind	<- ind+1
#		}
}
return (list(Exp=MatExp, Pert=Nom))
}		# MExp2
nbN	   <-  3					# Nombre de nœuds
MExper	   <- matrix(c(1,0,0, 0,1,0, 0,0,1, -1,0,0, 0,-1,0, 0,0,-1, 0,1,1, 1,1,0, 1,0,1), nrow=3)
Pert	  <- c("Q1", "Q2", "Q3", "Q4", "Q5", "Q6", "Q7", "Q8", "Q9")
F3 <- function(P,X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
#	où X représente les niveaux d'expression de pRaF, ppMEK, ppERK respectivement.
st 		<- c(0.1, 0.1, 0.1)	# Point de départ de la recherche d'optimum. De ce point, on converge vers la solution.
P0 		<- c(1, 1, 1)		# Valeur initiale des paramètres
MExp_		<- MExp2 (nbN, MExper, 0.01, P0, F3, st)
library(rootSolve)
MExp_		<- MExp2 (nbN, MExper, 0.01, P0, F3, st)
MExp_
MExp2	<- function (nbN, MapExper, Perturb, P0, func, st) {
#	nbP			<- length(Perturbs)
nbP			<- dim(MapExper)[2]							# Number of perturbations
cat("nbP", nbP,"\n")
MatExp		<- matrix (0, nrow=nbN, ncol=nbP+1)
Nom			<- vector(length=nbP+1)
F <- function(X) {return (func(P,X))}
P		<- P0
MatExp[ ,1]	<- (multiroot (f=F, start= st))$root
for (iPert in 1:nbP) {
#		Perturb	<- Perturbs[iPert]		# Perturb compris entre -1 et +1 ???
P	<- P0
for (iPar in 1:nbN) {
P[iPar]		<- P[iPar]*(1+Perturb*MapExper[iPar,iPert])
}
cat("iPert",iPert, "P \n")
print(P)
MatExp[ ,iPert+1]	<- (multiroot (f=F, start= st))$root
}
Nom[1]	<- "Base"
#	ind		<- 2
for (iPert in 1:nbP) {
#		for (iNode in 1:nbN) {
#			val	<- paste("Q", iNode, letters[iPert], "->N", iNode, sep="")		# valid up to 26 perturbs. otherwise, use "sequence_letters" in MRARegress
Nom[iPert+1]	<- paste("Q", letters[iPert],  sep="")		# valid up to 26 perturbs. otherwise, use "sequence_letters" in MRARegress
#			ind	<- ind+1
#		}
}
return (list(Exp=MatExp, Pert=Nom))
}		# MExp2
MExp_		<- MExp2 (nbN, MExper, 0.01, P0, F3, st)
MExp_
MExp2	<- function (nbN, MapExper, Perturb, P0, func, st) {
#	nbP			<- length(Perturbs)
nbP			<- dim(MapExper)[2]							# Number of perturbations
cat("nbP", nbP,"\n")
MatExp		<- matrix (0, nrow=nbN, ncol=nbP+1)
Nom			<- vector(length=nbP+1)
F <- function(X) {return (func(P,X))}
P		<- P0
MatExp[ ,1]	<- (multiroot (f=F, start= st))$root
for (iPert in 1:nbP) {
#		Perturb	<- Perturbs[iPert]		# Perturb compris entre -1 et +1 ???
P	<- P0
for (iPar in 1:nbN) {
P[iPar]		<- P[iPar]*(1+Perturb*MapExper[iPar,iPert])
}
cat("iPert",iPert, "P \n")
print(P)
MatExp[ ,iPert+1]	<- (multiroot (f=F, start= st))$root
}
Nom[1]	<- "Base"
#	ind		<- 2
for (iPert in 1:nbP) {
#		for (iNode in 1:nbN) {
#			val	<- paste("Q", iNode, letters[iPert], "->N", iNode, sep="")		# valid up to 26 perturbs. otherwise, use "sequence_letters" in MRARegress
Nom[iPert+1]	<- paste("Q", iPert,  sep="")		# valid up to 26 perturbs. otherwise, use "sequence_letters" in MRARegress
#			ind	<- ind+1
#		}
}
return (list(Exp=MatExp, Pert=Nom))
}		# MExp2
MExp_		<- MExp2 (nbN, MExper, 0.01, P0, F3, st)
MExp_
AA <- MRARegress (MExp_$Exp, MExp_$Pert, Method=Order2, MapExper=MExper, Relative=FALSE)
A <- MRARegress (MExp_$Exp, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A
MExp_		<- MExp2 (nbN, MExper, -0.01, P0, F3, st)
A <- MRARegress (MExp_$Exp, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$Order2
MExp_		<- MExp2 (nbN, MExper, -0.1, P0, F3, st)
A <- MRARegress (MExp_$Exp, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$Order2
MExp_		<- MExp2 (nbN, MExper, 0.1, P0, F3, st)
MRARegress (MExp_$Exp, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)$Order2
MExp_		<- MExp2 (nbN, MExper, -0.8, P0, F3, st)
MRARegress (MExp_$Exp, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)$Order2
MExp_		<- MExp2 (nbN, MExper, 0.8, P0, F3, st)
MRARegress (MExp_$Exp, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)$Order2
P0 		<- c(1, 1, 1)			# Valeur des paramètres
st 		<- c (0.1, 0.1, 0.1)
Perturbs	<- c(0.99999)
F <- function(P,X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
#	où X représente les niveaux d'expression de pRaF, ppMEK, ppERK respectivement.
MExp_3 	<-  MExp (nbN, Perturbs, P0, F, st)$Exp
MExp_3
mean(MExpe_3[,1])
mean(MExp_3[,1])
.05*mean(MExp_3[,1])
0.25*mean(MExp_3[,1])
nbN	   <-  3					# Nombre de nœuds
MExper	   <- matrix(c(1,0,0, 0,1,0, 0,0,1, -1,0,0, 0,-1,0, 0,0,-1, 0,1,1, 1,1,0, 1,0,1), nrow=3)
F3 <- function(P,X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
#	où X représente les niveaux d'expression de pRaF, ppMEK, ppERK respectivement.
st 		<- c(0.1, 0.1, 0.1)	# Point de départ de la recherche d'optimum. De ce point, on converge vers la solution.
P0 		<- c(1, 1, 1)		# Valeur initiale des paramètres
MExp_		<- MExp2 (nbN, MExper, 0.01, P0, F3, st)
MExp_
?rnorm
nbN	   <-  3					# Nombre de nœuds
MExper	   <- matrix(c(1,0,0, 0,1,0, 0,0,1, -1,0,0, 0,-1,0, 0,0,-1, 0,1,1, 1,1,0, 1,0,1), nrow=3)
F3 <- function(P,X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
#	où X représente les niveaux d'expression de pRaF, ppMEK, ppERK respectivement.
st 		<- c(0.1, 0.1, 0.1)	# Point de départ de la recherche d'optimum. De ce point, on converge vers la solution.
P0 		<- c(1, 1, 1)		# Valeur initiale des paramètres
MExp_		<- MExp2 (nbN, MExper, 0.01, P0, F3, st)	# Valeurs non bruitées
set.seed(12345)			# Indispensable pour retrouver les mêmes valeurs des va
Noise		<- rnorm (30, sd=0.2698)
MExpN_	<- MExp_+Noise
MExp_
MExpN_	<- MExp_$Exp + Noise
MExp_$Exp
MExpN_
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$Order2
A$r
B<-MRARegress (MExpN_, MExp_$Pert, MapExper=MExper, Relative=FALSE)
B$r
C<-MRARegress (MExp_$Exp, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
C$r
0.01*mean(MExp_3[,1])
set.seed(12345)			# Indispensable pour retrouver les mêmes valeurs des va
Noise		<- rnorm (30, sd=0.05396)
MExpN_	<- MExp_$Exp + Noise
MExpN_
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
A$Order2
Noise
MExp_		<- MExp2 (nbN, MExper, -0.01, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$Order2
A$r
MExp_		<- MExp2 (nbN, MExper, 0.01, P0, F3, st)
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, -0.1, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, 0.1, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, -0.8, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, 0.8, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
Noise		<- rnorm (30, sd=0.5396)
Noise
nbN
MExp_		<- MExp2 (nbN, MExper, -0.01, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, 0.01, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, -0.1, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, 0.1, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, -0.8, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, 0.8, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="Order2", MapExper=MExper, Relative=FALSE)
A$r
MExp_		<- MExp2 (nbN, MExper, -0.1, P0, F3, st)	# Valeurs non bruitées
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Method="TLR", MapExper=MExper, Relative=FALSE)
A$r
Perturbs	<- c(0.90, 1.10)		# Deux perturbations : -10% et +10%
MExp_		<- MExp (nbN, Perturbs, P0, F3, st)
MExpN_	<- MExp_$Exp + Noise
Noise
MExp_$Exp
MExp_$Pert
set.seed(12345)			# Indispensable pour retrouver les mêmes valeurs des va
Noise		<- rnorm (21, sd=0.5396)
Perturbs	<- c(0.90, 1.10)		# Deux perturbations : -10% et +10%
MExp_		<- MExp (nbN, Perturbs, P0, F3, st)
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Relative=FALSE)
A$r
Noise		<- rnorm (21, sd=0.05396)
Perturbs	<- c(0.90, 1.10)		# Deux perturbations : -10% et +10%
MExp_		<- MExp (nbN, Perturbs, P0, F3, st)
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Relative=FALSE)
A$r
set.seed(12345)			# Indispensable pour retrouver les mêmes valeurs des va
Noise		<- rnorm (30, sd=0.5396)
Perturbs	<- c(0.99, 0.90, 1.10)		# Deux perturbations : -10% et +10%
MExp_		<- MExp (nbN, Perturbs, P0, F3, st)
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Relative=FALSE)
A$r
set.seed(12345)			# Indispensable pour retrouver les mêmes valeurs des va
Noise		<- rnorm (30, sd=0.05396)
Perturbs	<- c(0.99, 0.90, 1.10)		# Deux perturbations : -10% et +10%
MExp_		<- MExp (nbN, Perturbs, P0, F3, st)
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Relative=FALSE)
A$r
Perturbs	<- c(0.95, 0.90, 1.10)		# Deux perturbations : -10% et +10%
MExp_		<- MExp (nbN, Perturbs, P0, F3, st)
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Relative=FALSE)
A$r
Perturbs	<- c(0.80, 0.90, 1.10)		# Deux perturbations : -10% et +10%
MExp_		<- MExp (nbN, Perturbs, P0, F3, st)
MExpN_	<- MExp_$Exp + Noise
A<-MRARegress (MExpN_, MExp_$Pert, Relative=FALSE)
A$r
data(MatExp1)
MatExp1
MatExp2
library(MRARegress)
detach("package:MRARegress", unload = TRUE)
library(covr)
covr <- package_coverage(path=".")
report(covr)
library(MRARegress)
library(MRARegress)
View(covr)
report(covr)
report(covr)
report(covr)
report(covr)
