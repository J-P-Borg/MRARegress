return ("Insufficient number of nodes !")
if (nbBase < 1)
return ("Insufficient number of basal columns !")
if (nbPc < 1)
return ("Insufficient number of perturbations !")
if (nbM < 1)
return ("Insufficient number of parameters (rows of MapExper) !")
# MatExp
if (! is.matrix(MatExp))
return ("MatExp must be a matrix !")
if (! is.numeric(MatExp))
return ("MatExp must contain numbers only !")
# Perturb
if (is.null(Perturb) && (nbP != nbN) && is.null(MapExper))
return ("Perturb is NULL and nb. perturbations != nb. nodes !")
if (! is.null(Perturb)) {
if (! is.vector(Perturb))
return ("Perturb must be NULL or a vector !")
if (length(Perturb) != dim(MatExp)[2])
return ("Perturb must be NULL or have as many columns as MatExp !")
if (nbBase <= 0)
return ("Perturb must contain one basal column at least !")
if (! is.null(MapExper) && (nbBase > 1))
return ("Perturb must contain exactly one basal column if MapExper is NOT NULL !")
}
# NodeName
if (! is.null(NodeName)) {
if (! is.vector(NodeName))
return ("NodeName must be NULL or a vector !")
if (length(NodeName) != nbN)
return ("NodeName must be NULL or have as many rows as MatExp !")
if (! is.character(NodeName))
return ("NodeName must be NULL or contain strings only !")
if (any(duplicated(NodeName)))
return ("Many nodes have the same name !")
}
# KnlgMap
if (! is.null(KnlgMap)) {
if (! is.matrix(KnlgMap))
return ("KnlgMap must be NULL or a matrix !")
if (dim(KnlgMap)[1] != dim(KnlgMap)[2])
return ("KnlgMap must be NULL or a square matrix !")
if (dim(KnlgMap)[1] != nbN)
return ("KnlgMap must be NULL or have as many rows as MatExp !")
if (sum(! (KnlgMap %in% c(0, 1, -1, "0", "1", "-1", "x"))) > 0 )
return ("KnlgMap must contain '0', '1', '-1' or 'x' only !")
if (Method != "TLR")
return ("KnlgMap works only with 'TLR' method !")
}
# Method
if (! is.character(Method))
return ("Method must be a string !")
if (! (Method %in% c("TLR", "LASSO", "RIDGE", "Elastic Net", "STEP", "ARACNE", "CLR", "MRNET", "Random Forest", "Order2")))
return ("Unknown method !")
# Hyper parameters
if (! is.null(Hyp_Lbda)) {
if (! is.numeric(Hyp_Lbda))
return ("Hyper parameter Hyp_Lbda must be NULL or a number !")
if (Hyp_Lbda < 0)
return ("Hyper parameter Hyp_Lbda must be NULL or a positive number !")
}
if (! is.numeric(Hyp_Mu))
return ("Hyper parameter Hyp_Mu must be NULL or a number !")
if (Hyp_Mu < 0)
return ("Hyper parameter Hyp_Mu must be NULL or a number between 0 and 1 !")
if (Hyp_Mu > 1)
return ("Hyper parameter Hyp_Mu must be NULL or a number between 0 and 1 !")
if (! (Hyp_Step %in% c("Fo", "Ba", "Bo")))
return ("Unknown Hyper parameter Hyp_Step !")
if (! is.numeric(Hyp_Eps))
return ("Hyper parameter Hyp_Eps must be NULL or a number !")
if (Hyp_Eps < 0)
return ("Hyper parameter Hyp_Eps must be NULL or a positive number !")
if (! is.numeric(Hyp_Cvx))
return ("Hyper parameter Hyp_Cvx must be NULL or a number !")
if (Hyp_Cvx < 0)
return ("Hyper parameter Hyp_Cvx must be NULL or a positive number !")
# MapExper
if (! is.null(MapExper)) {
if (! is.matrix(MapExper))
return ("MapExper must be NULL or a matrix !")
if (dim(MapExper)[2] != nbPc)
return ("MapExper must be NULL or have as many columns as the number of conducted perturbations !")
}
# ParNode
if (! is.null(ParNode)) {
if (! is.matrix(ParNode))
return ("ParNode must be NULL or a matrix !")
if (dim(ParNode)[1] != nbN || dim(ParNode)[2] != nbM)
return ("ParNode must be NULL or have as many rows as the number of nodes and as many columns as the number parameters !")
}
# Relative
if (! (Relative %in% c("TRUE", "FALSE"))) {
return ("Relative must be TRUE or FALSE !")
}
# Verbose
if (! (Verbose %in% c("TRUE", "FALSE"))) {
return ("Verbose must be TRUE or FALSE !")
}
# NoPrint
if (! (NoPrint %in% c("TRUE", "FALSE"))) {
return ("NoPrint must be TRUE or FALSE !")
}
# Number of perturbations
if (nbP < nbN)
return ("Not enough perturbations to get result !")
if (! is.null(MapExper) && ! (dim(MapExper)[1] == nbN && dim(MapExper)[2] == nbN && all(MapExper == IdentM)) 	&& (nbP < (nbN-1+nbM)))
return ("Not enough perturbations to get result !")
return (NULL)			# No error detected
}		# CheckInputData
#' Computes the "Connectivity Matrix" using ELASTICNET, RIDGE or LASSO Method (library glmnet)
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param Lbda		Hyper parameter λ of the method  -- If Lbda = NULL, a "best value" of Lbda is computed directly
#'@param Mu			Hyper parameter μ of the method  -- Mu = 0 : RIDGE, Mu = 1 : LASSO, else (between 0 and 1) : Elastic Net.
#'@param nbN		Number of nodes
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise (vector, length = nbN)
#'
fELASTIC	<- function (MatU, MatY, Lbda, Mu, nbN) {
tryCatch (
expr = {
rL 			<- vector(length=nbN)													# Result of Lasso method (ie sol. of Yi = Ai * Ui)
if (is.null(Lbda)) {
cv_model 	<- cv.glmnet(MatU, MatY, alpha = Mu, grouped = FALSE)				# Fits lasso regression model using k-fold cross-validation
Lbda		<- cv_model$lambda.min
}
best_model 	<- glmnet(MatU, MatY, alpha = Mu, lambda = Lbda, grouped = FALSE) 		# View coefficients of best model
rL			<-	coef(best_model)
return (rL)
},		# expr
error = function (e) {
message ("Error detected in ELASTIC method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fELASTIC
#' Computes the "Connectivity Matrix" using STEP Method
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param Meth		Hyper parameter of the method  -- "Fo" => "STEP-Fo", "Ba" => "STEP-Ba", "Bo" => "STEP-Bo"
#'@param nbN		Number of nodes
#'@param Verbose	Logical. If TRUE, additional printings are made. These printings are for internal use only, so they are not documented.
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise  (vector, length = nbN-1)
#'
fSTEP	<- function (MatU, MatY, Meth, nbN, Verbose) {
tryCatch (
expr = {
rij 		<- matrix(nrow=1, ncol=nbN-1)			# Intermediate calculation of rij - Use a matrix instead of a vector to use 'colnames'
Donnees  <- data.frame(MatY, MatU)
if (Verbose) {
cat(" Data ", colnames(Donnees), "\n")
}
Donnees	 <- rename(Donnees, "Y" ="MatY")			# The follow-up is clearer like this
cc 		 <- colnames(Donnees)						# Name of the columns "Data". The first one is "Y"
cc		 <- cc[-1]									# It remains the name of the coefficients ("X1", "X2", ... "Xn"  -- n = nbN-1)
colnames(rij) <- cc									# STEP gives the column names corresponding to the coefficients that are kept
switch(Meth,
"Fo" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(intercept_only, direction='forward', scope=formula(all), trace=0)},	# Forward
"Ba" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(all, direction='backward', scope=formula(all), trace=0)},				# Backward
"Bo" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(intercept_only, direction='both', scope=formula(all), trace=0)},		# Both
)
ll  	<- length(forward$coefficients)				# Number of coefficients kept by step
nn		<- names(forward$coefficients)				# Name of these coefficients
rij[1, ]	<- 0
if (ll >= 2) {
for (i in 2:ll) {								# nn[1] = "(Intercept)"
rij[1, nn[i]] <- forward$coefficients[nn[i]]
}
}
if (Verbose) {
cat (" ll ", ll, " nn ", nn, " rij ", rij, "\n")
}
return(rij[1, ])
},		# expr
error = function (e) {
message ("Error detected in STEP method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fSTEP
#' Computes the "Connectivity Matrix" using Random Forest Method (library randomForest)
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param seqLetters	A sequence of lower case letters "a", "b" .... used to name the columns
#'@param nbN		Number of nodes
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise  (vector, length = nbN-1)
#'
fRForest	<- function (MatU, MatY, seqLetters, nbN) {
tryCatch (
expr = {
rL 			<- vector(length=nbN-1)					# Result of Random Forest method
nbLmin		<- 80									# minimum number of rows to use Random Forest method
MatA		<- cbind(MatY, MatU)
nr			<- nrow(MatA)
nrep		<- round(nbLmin/nr)
MatB		<- MatA
if (nrep > 1) {
for (i in 1:nrep) {									# to have enough rows
MatB	<- rbind(MatB, MatA)
}
}
colnames(MatB)	<- c("Y", seqLetters)
rf			<- randomForest(Y ~ ., data=MatB, importance=TRUE)
rL			<- importance(rf)[,1]/sum(abs(importance(rf)[,1]))
return (rL)
},		# expr
error = function (e) {
message ("Error detected in Random Forest method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fRForest
#' Computes a sequence of letters : "a", "b", "c", ...., "z", "aa", "ab", .... , "az", "ba", "bb" etc ....
#'
#'@param	n		The number of elements of the sequence
#'
#'
#' @return			A vector, length n, containing the sequence of letters
#'
sequence_letters <- function(n) {
tryCatch (
expr = {
seq <- character(n)
letters <- c(letters, "")
for (i in 1:n) {
indices <- c()
k <- i - 1
while (k >= 0) {
indices <- c((k %% 26) + 1, indices)
k <- k %/% 26 - 1
}
seq[i] <- paste0(letters[indices], collapse = "")
}
return(seq)
},		# expr
error = function (e) {
message ("Error detected in sequence_letters function!")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# sequence_letters
#' Computes a squared value
#'
#'@param	x		The value to square (may be a vector)
#'
#'
#' @return			A vector, with the values squared
#'
fcarre	= function(x) {x^2}
MatExp	<- matrix(c(1,2,3, 11,21,31, 12,22,32, 13,23,33),nrow=3)	# 3 nodes, 3 perturbations, Base : 1st column
Ret		<- MRARegress (MatExp, Relative=FALSE)
#'@title "DrawGraph" :   Displays "r" as a graph
#'
#'@description : this function represents the Connectivity Matrix "r" as a graph where the nodes are the genes (for instance)
#'	and an edge A $\\rightarrow$ B reflects the action of node A on node B (amplification), while a dashed line (with a "T" arrow  betwwen A and B) reflects an inhibition
#'	of node B by node A.
#'	The graph is a "valued oriented graph", and values, next to edges, mean the "strength" of this action.
#'
#'@param  Ret	List or Matrix		list of informations delivered by "MRARegress" or square matrix of numbers.
#'									If 'Ret' is a list of informations delivered by "MRARegress", DrawGraph uses 'Ret$r' (connectivity matrix)
#'									and 'Ret$InputPar$NodeName' (name of the nodes).
#'									If 'Ret' is a square matrix, it corresponds to a connectivity matrix, and the names of the nodes are the names of the columns if defined,
#'									or a sequence of numbers if not.
#'@param  Title	String				Title of the graph. Default value is NULL.
#'@param  Thr	Number (>= 0)		A threshold to determine edge existence. Default value is 0.1.
#'									An edge is drawn between nodes 'i' and 'j' iff connectivity coefficient is >= Thr (ie \|MatrCc\[i,j\]\| >= Thr)
#'
#'@details
#'		Imported libraries :
#'		- BiocManager (version 1.30.22). To install this version, R version >= 4.3 is mandatory
#'		- RCy3							Communication with Cytoscape
#'		- utils	compareVersion			To check Cytoscape version
#'
#'		Cytoscape (version >= 3.6.1) must be installed and running.
#'
#'	OUTPUT:
#'
#'  	theGraph	List of dataframes
#'					nodes (list of nodes : name, PValN), edges (list of edges : source, target, interaction, value).
#'		Variables	list of the input parameters values. NULL values are set to their default values.
#'					list of important variables used by the program (Thr, nbN, MatrCc, nodesName).
#'@import BiocManager
#'@import RCy3
#'@importFrom utils   compareVersion
#'
#'
#'@name			DrawGraph
#'
#'@description	Displays the graph associated with the connectivity matrix.
#'				The input data are described above and the outputs below.
#'
#'@return		List			NULL in case of error or a list of informations ("theGraph", "Variables"). For internal use only.
#'@export
#'
DrawGraph <- function (Ret, Title=NULL, Thr=0.1) {
tryCatch (
expr = {
cat ("START DrawGraph !", as.character(Sys.time()), "\n")
toReturn	<- list()			# Return values
toReturn[["theGraph"]]	<- NULL
toReturn[["Variables"]]	<- NULL
# Check Cytoscape connection and version
cytoscapePing()
Vers	<- cytoscapeVersionInfo ()
if (compareVersion(Vers[2], "3.6.1") < 0)	{
message ("Cytoscape too old. Download the latest version !")
return (NULL)
}
# Check input data
err	<-  CheckInputDataDG (Ret, Title, Thr)
if (! is.null(err)) {
message (err)
return (NULL)
}
# Variables declaration
if (is.matrix(Ret)) {
nbN			<- dim(Ret)[1]									# Number of nodes (nb. of rows)
if (is.null (rownames(Ret))) {
nodesName	<- as.character(seq(1:nbN))					# Name of the nodes
} else {
nodesName	<- rownames(Ret)							# Name of the nodes
}
MatrCc		<- Ret											# Connectivity matrix
PValN		<- vector(length=nbN)							#  pVal[SSR] or pVal[LOF] cannot be computed for the nodes
PValN[]		<- -1
} else {
nbN			<- Ret$Input$Variables$nbN						# Number of nodes (nb. of rows)
nodesName	<- Ret$Input$InputPar$NodeName					# Name of the nodes
MatrCc		<- Ret$r										# Connectivity matrix
PValN		<- Ret$PValN									# pVal (SSR and LOF) regarding the nodes
#	A	: pVal[SSR] or pVal[LOF] cannot be computed.
#	B	: Measures are NOT explained by the model : pVal[SSR] >= tlrSSR
#	C	: Measures are explained by the model, residual errors do not correspond to the noise level : pVal[SSR] < tlrSSR AND  pVal[LOF] < tlrLOF,
#	D	: Measures are explained by the model, residual errors correspond to the noise level : pVal[SSR] < tlrSSR AND  pVal[LOF] >= tlrLOF
}
Id			<- NULL												# Name of the nodes
pVal		<- NULL												# pVal regarding the nodes
source		<- NULL												# Source of the edges
target		<- NULL												# Target of the edges
interaction	<- NULL												# Source action on target : "d" : amplifies, "r" : inhibits
value		<- NULL												# Action magnitude
# Network construction
for (iNode in 1:nbN) {
Id		<- c(Id, nodesName[iNode])
pVal	<- c(pVal, PValN[iNode])
}
nodes	<- data.frame(id=Id, group=pVal, stringsAsFactors=FALSE)														# List of the nodes
diag(MatrCc)	<- 0
for (jCol in 1:nbN) {
for (iRow in 1:nbN) {
if (abs(MatrCc[iRow,jCol]) < Thr)
next
source	<- c(source, nodesName[jCol])
target	<- c(target, nodesName[iRow])
value	<- c(value,  MatrCc[iRow,jCol] %>% round(3))
if (MatrCc[iRow,jCol] > 0)
interaction	<- c(interaction, "d")
else
interaction	<- c(interaction, "r")
}
}
edges	<- data.frame(source=source, target=target, interaction=interaction, value=value, stringsAsFactors=FALSE)		# List of the edges
createNetworkFromDataFrames (nodes,edges, title=Title, collection="MRARegress_tests")
toReturn$theGraph	<- list (nodes, edges)
toReturn$Variables	<- list (Thr, nbN, MatrCc, nodesName)
# Style definition
style.name	<- "MRARegress_style"
defaults	<- list(
#						NODE_FILL_COLOR = "#89D0F5",
NODE_SIZE		= 35,
EDGE_SOURCE_ARROW_SIZE	= 6.0,
EDGE_TARGET_ARROW_SIZE	= 6.0,
EDGE_WIDTH				= 2.0,
EDGE_LABEL_AUTOROTATE	= TRUE,					# The edge label will be automatically rotated so that the label aligns with the edge
EDGE_LABEL_POSITION		= "C,C,c,0.00,-8.00")	# The position of the edge label relative to the edge. Centered, vertical offset -8 px
nodeLabels 		<- mapVisualProperty('node label','id','p')		# Nodes name comes from "id" and "passthrough"
nodeFills		<- mapVisualProperty('node fill color', 'group', 'd', c("A","B","C","D"), c("#FC4E2A","#FC4E2A","#FEB24C","#9ECAE1"))	# Node colour according to PValN
arrowShapes		<- mapVisualProperty('Edge Target Arrow Shape','interaction','d',c("d","r"),c("Arrow","T"))
# Shape of the arrow, according to discrete values ('d'). Possible values are "d" or "r". Corresponding extremity shape "Arrow" or "T"
edgeLabels		<- mapVisualProperty('edge label','value','p','float')
edgeLineType	<- mapVisualProperty('edge line type','interaction','d',c("d","r"),c("SOLID","EQUAL_DASH"))
createVisualStyle (style.name, defaults, list(nodeLabels,nodeFills,arrowShapes,edgeLabels,edgeLineType))
setVisualStyle (style.name)
cat ("DONE !", as.character(Sys.time()), "\n")
return (toReturn)
},		# expr
warning = function (e) {
message ("Warning detected !")
print(e)
return (toReturn)
},		# warning
error = function (e) {
message ("Error detected !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# DrawGraph
#' Checks the input data for function DrawGraph
#'
#' This function checks the input data for function DrawGraph.
#' The parameters are the same as those of DrawGraph.
#'
#'@param Ret		list of informations delivered by "MRARegress" or a square matrix.
#'@param Title		Title of the graph.
#'@param Thr		Threshold to determine edge existence
#'
#'
#' @return 			A message if an error is detected and returns NULL otherwise.
#'
CheckInputDataDG	<- function (Ret, Title, Thr) {
tryCatch (
expr = {
# Test input data : Ret or Matr
if (is.vector(Ret, mode="numeric")) {
return ("Ret must not be a vector !")
}
if (is.matrix(Ret)) {
if (dim(Ret)[1] != dim(Ret)[2])
return ("If 'Ret' is a matrix, it must be a square matrix !")
if (! is.numeric(Ret))
return ("If 'Ret' is a matrix, it must contain numbers only !")
} else {
# Variables declaration
KeysR		<- Ret$Input$Variables$Keys						# Keys read
KeysC		<- vector(length=4)								# Keys computed from data
nbN			<- Ret$Input$Variables$nbN						# Number of nodes
nbPc		<- Ret$Input$Variables$nbPc                   # Number of conducted perturbations
nbBase		<- Ret$Input$Variables$nbBase                 # Number of basal columns
MatD		<- Ret$Input$Variables$MatD                   # Matrix (2*(Xi,j-Xi) / (Xi,j+Xi) or Xi,j-Xi) transposed and coordinates of the perturbations vs. parameters.
MatExp		<- Ret$Input$InputPar$MatExp					# "Expression Matrix", see the document "Projet de mémoire de thèse - 1° partie"
# Calculation of the keys
KeysC[1]	<-	 3*nbN +  7*(nbPc+nbBase)
KeysC[2]	<-	19*nbN + 37*(nbPc+nbBase)
KeysC[3]	<-	sum(abs(MatD[ , ]))
KeysC[4]	<-	sum(abs(MatExp[1, ])) + sum(abs(MatExp[ ,1]))
if (KeysC[1] != KeysR[1] || KeysC[2] != KeysR[2] || KeysC[3] != KeysR[3] || KeysC[4] != KeysR[4])
return ("Ret is NOT a valid return from MRARegress !")
}
# Test 'Title'
if (! is.null(Title) && ! is.character(Title))
return ("Title must be NULL or a string !")
# Test threshold value
if (! is.numeric(Thr))
return ("Thr must be a number !")
if (Thr <= 0)
return ("Thr must be a strictly positive number !")
return (NULL)			# No error detected
},		# expr
warning = function (e) {
message ("DrawGraph : check input parameters : Warning detected !")
print(e)
return ("Warning")
},		# warning
error = function (e) {
message ("DrawGraph : check input parameters : Error detected !")
print(e)
}		# error
)			# tryCatch
return ("Error")
}		# CheckInputDataDG
RetDG	<- DrawGraph (Ret)
library(BiocManager)
RetDG	<- DrawGraph (Ret)
library(magrittr)
RetDG	<- DrawGraph (Ret)
library(MRARegress)
MatExp	<- matrix(c(1,2,3, 11,21,31, 12,22,32, 13,23,33),nrow=3)	# 3 nodes, 3 perturbations, Base : 1st column
Ret		<- MRARegress (MatExp, Relative=FALSE)
RetDG	<- DrawGraph (Ret)
MatExp2
Solution
Dg	<- DrawGraph (Solution)
Ret	<- MRARegress (MatExp2, Perturb2)
if (! is.null(Ret)) {
MatrCcDiscr	<- Classify(Ret)						# Classes = c(0,1), Method = "TLR", Lbda = NULL (default values)
Trash <- DrawDiscr (MatrCcDiscr, Solution)
)
if (! is.null(Ret)) {
MatrCcDiscr	<- Classify(Ret)						# Classes = c(0,1), Method = "TLR", Lbda = NULL (default values)
Trash <- DrawDiscr (MatrCcDiscr, Solution)					# Draws the second image
}
library(MRARegress)
MatExp	<- matrix(c(1,2,3, 11,21,31, 12,22,32, 13,23,33),nrow=3)	# 3 nodes, 3 perturbations, Base : 1st column
Ret		<- MRARegress (MatExp, Relative=FALSE)
RetDG	<- DrawGraph (Ret)
library(MRARegress)
MatExp	<- matrix(c(1,2,3, 11,21,31, 12,22,32, 13,23,33),nrow=3)	# 3 nodes, 3 perturbations, Base : 1st column
Ret		<- MRARegress (MatExp, Relative=FALSE)
RetDG	<- DrawGraph (Ret)
