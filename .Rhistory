Anovas["Pure","Sum",iNode]	<- sum(ZIMes[ ])
Anovas["LOF","Sum",iNode]	<- Anovas["SSE","Sum",iNode] - Anovas["Pure","Sum",iNode]
Anovas["TSS","Sum",iNode]	<- sum(sapply(MatY0-ZMean, fcarre))		# df=n
# 3/ Means
Anovas[ ,"Mean",iNode]	<- Anovas[ ,"Sum",iNode] / Anovas[ ,"df",iNode]
# 4/ F  (Fisher/Snedecor) and pVal
Anovas["SSR","F",iNode]	<- Anovas["SSR","Mean",iNode] / Anovas["SSE","Mean",iNode]
if ((Anovas["SSR","df",iNode]>0) && (Anovas["SSE","df",iNode]>0))
Anovas["SSR","pVal",iNode]	<- 	pf(Anovas["SSR","F",iNode], Anovas["SSR","df",iNode], Anovas["SSE","df",iNode], lower.tail=FALSE)
else
bSSR	<- FALSE
Anovas["LOF","F",iNode]	<- Anovas["LOF","Mean",iNode] / Anovas["Pure","Mean",iNode]
if ((Anovas["LOF","df",iNode]>0) && (Anovas["Pure","df",iNode]>0))
Anovas["LOF","pVal",iNode]	<- 	pf(Anovas["LOF","F",iNode], Anovas["LOF","df",iNode], Anovas["Pure","df",iNode], lower.tail=FALSE)
else
bLOF	<- FALSE
# 5/ Results
if (Verbose) {
cat ("iNode", iNode, "p", nbN-1, "n", nbRowsY0, "m", nbMeas, " Anovas \n")
print (Anovas[ , ,iNode])
}
}		# for iNode
}			# else ARACNE ...
# Rows and columns name
rownames(MatrCc)	<- NodeName
colnames(MatrCc)	<- MatrCcCol
# Results of ANOVA
Anova["SSR", "df/m"]	<-	min(Anovas["SSR", "df", ])
Anova["SSR", "df/M"]	<-	max(Anovas["SSR", "df", ])
Anova["SSR", "Sum/m"]	<-	min(Anovas["SSR", "Sum", ])
Anova["SSR", "Sum/M"]	<-	max(Anovas["SSR", "Sum", ])
Anova["SSR", "Mean/m"]	<-	min(Anovas["SSR", "Mean", ])
Anova["SSR", "Mean/M"]	<-	max(Anovas["SSR", "Mean", ])
Anova["SSR", "F/m"]		<-	min(Anovas["SSR", "F", ])
Anova["SSR", "F/M"]		<-	max(Anovas["SSR", "F", ])
Anova["SSR", "pVal/m"]	<-	min(Anovas["SSR", "pVal", ])
Anova["SSR", "pVal/M"]	<-	max(Anovas["SSR", "pVal", ])
Anova["SSR", "nbrNdes"]	<-	length(which(Anovas["SSR", "pVal", ] >= tlrSSR))			# length(which(Anova["SSR", "pVal/M"] > tlrSSR))
Anova["SSE", "df/m"]	<-	min(Anovas["SSE", "df", ])
Anova["SSE", "df/M"]	<-	max(Anovas["SSE", "df", ])
Anova["SSE", "Sum/m"]	<-	min(Anovas["SSE", "Sum", ])
Anova["SSE", "Sum/M"]	<-	max(Anovas["SSE", "Sum", ])
Anova["SSE", "Mean/m"]	<-	min(Anovas["SSE", "Mean", ])
Anova["SSE", "Mean/M"]	<-	max(Anovas["SSE", "Mean", ])
Anova["SSE", "F/m"]		<-	min(Anovas["SSE", "F", ])
Anova["SSE", "F/M"]		<-	max(Anovas["SSE", "F", ])
Anova["SSE", "pVal/m"]	<-	min(Anovas["SSE", "pVal", ])
Anova["SSE", "pVal/M"]	<-	max(Anovas["SSE", "pVal", ])
Anova["LOF", "df/m"]	<-	min(Anovas["LOF", "df", ])
Anova["LOF", "df/M"]	<-	max(Anovas["LOF", "df", ])
Anova["LOF", "Sum/m"]	<-	min(Anovas["LOF", "Sum", ])
Anova["LOF", "Sum/M"]	<-	max(Anovas["LOF", "Sum", ])
Anova["LOF", "Mean/m"]	<-	min(Anovas["LOF", "Mean", ])
Anova["LOF", "Mean/M"]	<-	max(Anovas["LOF", "Mean", ])
Anova["LOF", "F/m"]		<-	min(Anovas["LOF", "F", ])
Anova["LOF", "F/M"]		<-	max(Anovas["LOF", "F", ])
Anova["LOF", "pVal/m"]	<-	min(Anovas["LOF", "pVal", ], na.rm=TRUE)
Anova["LOF", "pVal/M"]	<-	max(Anovas["LOF", "pVal", ], na.rm=TRUE)
Anova["LOF", "nbrNdes"]	<-	length(which(Anovas["LOF", "pVal", ] < tlrLOF))				# length(which(Anova["LOF", "pVal/M"] > tlrLOF))
Anova["Pure", "df/m"]	<-	min(Anovas["Pure", "df", ])
Anova["Pure", "df/M"]	<-	max(Anovas["Pure", "df", ])
Anova["Pure", "Sum/m"]	<-	min(Anovas["Pure", "Sum", ])
Anova["Pure", "Sum/M"]	<-	max(Anovas["Pure", "Sum", ])
Anova["Pure", "Mean/m"]	<-	min(Anovas["Pure", "Mean", ])
Anova["Pure", "Mean/M"]	<-	max(Anovas["Pure", "Mean", ])
Anova["Pure", "F/m"]	<-	min(Anovas["Pure", "F", ])
Anova["Pure", "F/M"]	<-	max(Anovas["Pure", "F", ])
Anova["Pure", "pVal/m"]	<-	min(Anovas["Pure", "pVal", ], na.rm=TRUE)
Anova["Pure", "pVal/M"]	<-	max(Anovas["Pure", "pVal", ], na.rm=TRUE)
Anova["TSS", "df/m"]	<-	min(Anovas["TSS", "df", ])
Anova["TSS", "df/M"]	<-	max(Anovas["TSS", "df", ])
Anova["TSS", "Sum/m"]	<-	min(Anovas["TSS", "Sum", ])
Anova["TSS", "Sum/M"]	<-	max(Anovas["TSS", "Sum", ])
if (! bSSR) {
strSSR	<-	"Unable to compute SSR\n"
} else if (Anova["SSR", "nbrNdes"] > 0) {
strSSR	<- paste("The error is NOT explained by the regression used for ", Anova["SSR", "nbrNdes"], " nodes out of ", nbN, "!\n")
} else {
strSSR	<-	"Measures are explained by the model, at least partially !\n"
}
if (! bLOF) {
strLOF	<-	"Unable to compute LOF\n"
} else if (Anova["LOF", "nbrNdes"] > 0) {
strLOF	<- paste("Residual errors do not correspond to the noise level of the measurements for ", Anova["LOF", "nbrNdes"], " nodes out of ", nbN, "!\n")
} else {
strLOF	<-	"Residual errors are explained by the noise level !\n"
}
AnovaOut	<- list(Anova, strSSR, strLOF)
cat ("DONE !", as.character(Sys.time()), "\n")
toReturn$r		<- MatrCc
toReturn$Order2	<- MatO2
toReturn$ANOVA	<- AnovaOut
toReturn$Input	<- Input
return (toReturn)
},		# expr
warning = function (e) {
message ("Warning detected !")
print(e)
toReturn$r		<- MatrCc
toReturn$Order2	<- MatO2
toReturn$ANOVA	<- AnovaOut
toReturn$Input	<- Input
return (toReturn)
},		# warning
error = function (e) {
message ("Error detected !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# MRARegress
#' Checks the input data for function MRARegress
#'
#' This function checks the input data for function MRARegress.
#' The parameters are same as those of MRARegress.
#'
#'@param MatExp		The "Expression Matrix".
#'@param Perturb	Refers to the name of the perturbations and the nodes they act upon.
#'@param NodeName	The name of the nodes.
#'@param KnlgMap	The "Knowledge Map".
#'@param Method		The method used to compute the connectivity matrix.
#'@param Hyp_Lbda	Hyper parameter needed by the LASSO, RIDGE, Elastic Net methods.
#'@param Hyp_Mu		Hyper parameter μ of the method 'Elastic Net'
#'@param Hyp_Step	Hyper parameter μ of the method 'Step'
#'@param Hyp_Eps	Hyper parameter ε of the method 'aracne'
#'@param Hyp_Cvx	Hyper parameter used by KnlgMap
#'@param MapExper	The "Experience Map" matrix
#'@param ParNode	The "Parameters /Nodes relation" matrix
#'@param Relative	"Relative or absolute" values for the Global Response Matrix ("R")
#'@param Verbose	If TRUE, additional printings are made. These printings are for internal use only, so they are not documented.
#'
#'
#' @return 			A message if an error is detected and returns NULL otherwise.
#'
CheckInputData	<- function (MatExp, Perturb, NodeName, KnlgMap, Method, Hyp_Lbda, Hyp_Mu, Hyp_Step, Hyp_Eps, Hyp_Cvx, MapExper, ParNode, Relative, Verbose) {
# Variables declaration
nbN			<- dim(MatExp)[1]										# Number of nodes
nbBase		<- ifelse(is.null(Perturb), 1, sum(Perturb=="Base"))	# Number of basal columns
nbPc		<- dim(MatExp)[2] - nbBase								# Number of conducted perturbations
nbP			<- nbBase*nbPc											# Number of "perturbations" taken into account
# Test Input Variables
if (is.null(MapExper)) {
H6		<- TRUE
nbM		<- nbN													# Number of parameters
} else {
H6		<- FALSE
nbM		<- dim(MapExper)[1]										# Number of parameters
}
# nbN, nbBase, nbPc, nbM
if (nbN < 2)
return ("Insufficient number of nodes !")
if (nbBase < 1)
return ("Insufficient number of basal columns !")
if (nbPc < 1)
return ("Insufficient number of perturbations !")
if (nbM < 1)
return ("Insufficient number of parameters (rows of MapExper) !")
# MatExp
if (! is.matrix(MatExp))
return ("MatExp must be a matrix !")
if (! is.numeric(MatExp))
return ("MatExp must contain numbers only !")
# Perturb
if (is.null(Perturb) && (nbP != nbN) && is.null(MapExper))
return ("Perturb is NULL and nb. perturbations != nb. nodes !")
if (! is.null(Perturb)) {
if (! is.vector(Perturb))
return ("Perturb must be NULL or a vector !")
if (length(Perturb) != dim(MatExp)[2])
return ("Perturb must be NULL or have as many columns as MatExp !")
if (nbBase <= 0)
return ("Perturb must contain one basal column at least !")
if (! is.null(MapExper) && (nbBase > 1))
return ("Perturb must contain exactly one basal column if MapExper is NOT NULL !")
}
# NodeName
if (! is.null(NodeName)) {
if (! is.vector(NodeName))
return ("NodeName must be NULL or a vector !")
if (length(NodeName) != nbN)
return ("NodeName must be NULL or have as many rows as MatExp !")
if (! is.character(NodeName))
return ("NodeName must be NULL or contain strings only !")
if (any(duplicated(NodeName)))
return ("Many nodes have the same name !")
}
# KnlgMap
if (! is.null(KnlgMap)) {
if (! is.matrix(KnlgMap))
return ("KnlgMap must be NULL or a matrix !")
if (dim(KnlgMap)[1] != dim(KnlgMap)[2])
return ("KnlgMap must be NULL or a square matrix !")
if (dim(KnlgMap)[1] != nbN)
return ("KnlgMap must be NULL or have as many rows as MatExp !")
if (sum(! (KnlgMap %in% c(0, 1, -1, "0", "1", "-1", "x"))) > 0 )
return ("KnlgMap must contain '0', '1', '-1' or 'x' only !")
if (Method != "TLR")
return ("KnlgMap works only with 'TLR' method !")
}
# Method
if (! is.character(Method))
return ("Method must be a string !")
if (! (Method %in% c("TLR", "LASSO", "RIDGE", "Elastic Net", "STEP", "ARACNE", "CLR", "MRNET", "Random Forest", "Order2")))
return ("Unknown method !")
# Hyper parameters
if (! is.null(Hyp_Lbda)) {
if (! is.numeric(Hyp_Lbda))
return ("Hyper parameter Hyp_Lbda must be NULL or a number !")
if (Hyp_Lbda < 0)
return ("Hyper parameter Hyp_Lbda must be NULL or a positive number !")
}
if (! is.numeric(Hyp_Mu))
return ("Hyper parameter Hyp_Mu must be NULL or a number !")
if (Hyp_Mu < 0)
return ("Hyper parameter Hyp_Mu must be NULL or a number between 0 and 1 !")
if (Hyp_Mu > 1)
return ("Hyper parameter Hyp_Mu must be NULL or a number between 0 and 1 !")
if (! (Hyp_Step %in% c("Fo", "Ba", "Bo")))
return ("Unknown Hyper parameter Hyp_Step !")
if (! is.numeric(Hyp_Eps))
return ("Hyper parameter Hyp_Eps must be NULL or a number !")
if (Hyp_Eps < 0)
return ("Hyper parameter Hyp_Eps must be NULL or a positive number !")
if (! is.numeric(Hyp_Cvx))
return ("Hyper parameter Hyp_Cvx must be NULL or a number !")
if (Hyp_Cvx < 0)
return ("Hyper parameter Hyp_Cvx must be NULL or a positive number !")
# MapExper
if (! is.null(MapExper)) {
if (! is.matrix(MapExper))
return ("MapExper must be NULL or a matrix !")
if (dim(MapExper)[2] != nbPc)
return ("MapExper must be NULL or have as many columns as the number of conducted perturbations !")
}
# ParNode
if (! is.null(ParNode)) {
if (! is.matrix(ParNode))
return ("ParNode must be NULL or a matrix !")
if (dim(ParNode)[1] != nbN || dim(ParNode)[2] != nbM)
return ("ParNode must be NULL or have as many rows as the number of nodes and as many columns as the number parameters !")
}
# Relative
if (! (Relative %in% c("TRUE", "FALSE"))) {
return ("Relative must be TRUE or FALSE !")
}
# Verbose
if (! (Verbose %in% c("TRUE", "FALSE"))) {
return ("Verbose must be TRUE or FALSE !")
}
# Number of perturbations
if (nbP < nbN)
return ("Not enough perturbations to get result !")
if (! is.null(MapExper) && (nbP < (nbN-1+nbM)))
return ("Not enough perturbations to get result !")
return (NULL)			# No error detected
}		# CheckInputData
#' Computes the "Connectivity Matrix" using ELASTICNET, RIDGE or LASSO Method (library glmnet)
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param Lbda		Hyper parameter λ of the method  -- If Lbda = NULL, a "best value" of Lbda is computed directly
#'@param Mu			Hyper parameter μ of the method  -- Mu = 0 : RIDGE, Mu = 1 : LASSO, else (between 0 and 1) : Elastic Net.
#'@param nbN		Number of nodes
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise (vector, length = nbN)
#'
fELASTIC	<- function (MatU, MatY, Lbda, Mu, nbN) {
tryCatch (
expr = {
rL 			<- vector(length=nbN)													# Result of Lasso method (ie sol. of Yi = Ai * Ui)
if (is.null(Lbda)) {
cv_model 	<- cv.glmnet(MatU, MatY, alpha = Mu, grouped = FALSE)				# Fits lasso regression model using k-fold cross-validation
Lbda		<- cv_model$lambda.min
}
best_model 	<- glmnet(MatU, MatY, alpha = Mu, lambda = Lbda, grouped = FALSE) 		# View coefficients of best model
rL			<-	coef(best_model)
return (rL)
},		# expr
error = function (e) {
message ("Error detected in ELASTIC method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fELASTIC
#' Computes the "Connectivity Matrix" using STEP Method
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param Meth		Hyper parameter of the method  -- "Fo" => "STEP-Fo", "Ba" => "STEP-Ba", "Bo" => "STEP-Bo"
#'@param nbN		Number of nodes
#'@param Verbose	Logical. If TRUE, additional printings are made. These printings are for internal use only, so they are not documented.
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise  (vector, length = nbN-1)
#'
fSTEP	<- function (MatU, MatY, Meth, nbN, Verbose) {
tryCatch (
expr = {
rij 		<- matrix(nrow=1, ncol=nbN-1)			# Intermediate calculation of rij - Use a matrix instead of a vector to use 'colnames'
Donnees  <- data.frame(MatY, MatU)
if (Verbose) {
cat(" Data ", colnames(Donnees), "\n")
}
Donnees	 <- rename(Donnees, "Y" ="MatY")			# The follow-up is clearer like this
cc 		 <- colnames(Donnees)						# Name of the columns "Data". The first one is "Y"
cc		 <- cc[-1]									# It remains the name of the coefficients ("X1", "X2", ... "Xn"  -- n = nbN-1)
colnames(rij) <- cc									# STEP gives the column names corresponding to the coefficients that are kept
switch(Meth,
"Fo" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(intercept_only, direction='forward', scope=formula(all), trace=0)},	# Forward
"Ba" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(all, direction='backward', scope=formula(all), trace=0)},				# Backward
"Bo" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(intercept_only, direction='both', scope=formula(all), trace=0)},		# Both
)
ll  	<- length(forward$coefficients)				# Number of coefficients kept by step
nn		<- names(forward$coefficients)				# Name of these coefficients
rij[1, ]	<- 0
if (ll >= 2) {
for (i in 2:ll) {								# nn[1] = "(Intercept)"
rij[1, nn[i]] <- forward$coefficients[nn[i]]
}
}
if (Verbose) {
cat (" ll ", ll, " nn ", nn, " rij ", rij, "\n")
}
return(rij[1, ])
},		# expr
error = function (e) {
message ("Error detected in STEP method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fSTEP
#' Computes the "Connectivity Matrix" using Random Forest Method (library randomForest)
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param seqLetters	A sequence of lower case letters "a", "b" .... used to name the columns
#'@param nbN		Number of nodes
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise  (vector, length = nbN-1)
#'
fRForest	<- function (MatU, MatY, seqLetters, nbN) {
tryCatch (
expr = {
rL 			<- vector(length=nbN-1)					# Result of Random Forest method
nbLmin		<- 80									# minimum number of rows to use Random Forest method
MatA		<- cbind(MatY, MatU)
nr			<- nrow(MatA)
nrep		<- round(nbLmin/nr)
MatB		<- MatA
for (i in 1:nrep) {									# to have enough rows
MatB	<- rbind(MatB, MatA)
}
colnames(MatB)	<- c("Y", seqLetters)
rf			<- randomForest(Y ~ ., data=MatB, importance=TRUE)
rL			<- importance(rf)[,1]/sum(importance(rf)[,1])
return (rL)
},		# expr
error = function (e) {
message ("Error detected in Random Forest method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fRForest
#' Computes a sequence of letters : "a", "b", "c", ...., "z", "aa", "ab", .... , "az", "ba", "bb" etc ....
#'
#'@param	n		The number of elements of the sequence
#'
#'
#' @return			A vector, length n, containing the sequence of letters
#'
sequence_letters <- function(n) {
tryCatch (
expr = {
seq <- character(n)
letters <- c(letters, "")
for (i in 1:n) {
indices <- c()
k <- i - 1
while (k >= 0) {
indices <- c((k %% 26) + 1, indices)
k <- k %/% 26 - 1
}
seq[i] <- paste0(letters[indices], collapse = "")
}
return(seq)
},		# expr
error = function (e) {
message ("Error detected in sequence_letters function!")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# sequence_letters
#' Computes a squared value
#'
#'@param	x		The value to square (may be a vector)
#'
#'
#' @return			A vector, with the values squared
#'
fcarre	= function(x) {x^2}
Res2	<- MRARegress(MExp2, Pert2, Relative=FALSE)
Res2$ANOVA
library(MRARegress)
nbN	<-  3			# Nombre de noeuds
F3Nds <- function(P,X)
c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])),
F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])),
F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))
# où X représente les niveaux d'expression de pRaF, ppMEK, ppERK respectivement.
st 	<- c(0.1, 0.1, 0.1)	# Point de départ de la recherche d'optimum. De ce point, on converge vers la solution.
P0 	<- c(1, 1, 1)		 # Valeur initiale des paramètres
Perturbs  <- c(0.2, 0.9, 0.99)	 # Trois perturbations : -80%, -10%, -1%
MExp_	<- MExp(nbN, Perturbs, P0, F3Nds, st)
MExp_
set.seed(12345)
Bruit	<- matrix(rnorm(30, 0, 0.01), nrow=3)
MExp1	<- MExp_$Exp + Bruit
MExp2	<- cbind(MExp_$Exp, MExp1[ ,2:10])
Pert2	<- c(MExp_$Pert, MExp_$Pert[2:10])
Res2	<- MRARegress(MExp2, Pert2, Relative=FALSE)
Res2$ANOVA
Res_O2 <- MRARegress(MExp_$Exp,MExp_$Pert, Method="Order2", Relative=FALSE)
Res_O2$r
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
vignette("MRARegress", package = "MRARegress")
library(MRARegress)
?MRARegress
vignette("MRARegress", package = "MRARegress")
vignette
?vignette
vignette("MRARegress.html", package = "MRARegress")
vignette("MRARegress", package = "MRARegress", lib.loc = "C:/Users/jean-pierre.borg/IRCM/These/Recherche/Packages/MRARegress/vignettes")
vignette("MRARegress", package = "MRARegress")
library(MRARegress)
?MRARegress
vignette("MRARegress", package = "MRARegress")
devtools::install_github("J-P-Borg/MRARegress", build = TRUE, build_opts = c("--no-resave-data", "--no-manual"))
detach("package:MRARegress", unload = TRUE)
devtools::install_github("J-P-Borg/MRARegress", build = TRUE, build_opts = c("--no-resave-data", "--no-manual"))
library(MRARegress)
?MRARegress
?MRARegress
?stats
library(MRARegress)
?MRARegress
vignette("MRARegress", package = "MRARegress")
library(MRARegress)
?MRARegress
vignette("MRARegress", package = "MRARegress")
devtools::use_vignette
build_vignette()
?devtools
library(MRARegress)
vignette("MRARegress", package = "MRARegress")
devtools::install_github(build_vignettes = TRUE)
devtools::install_github("J-P-Borg/MRARegress", build_vignettes = TRUE)
vignette("MRARegress", package = "MRARegress")
detach("package:MRARegress", unload = TRUE)
devtools::install_github("J-P-Borg/MRARegress", build_vignettes = TRUE)
vignette("MRARegress", package = "MRARegress")
vignette("MRARegress")
devtools::build(vignettes=TRUE)
vignette("MRARegress", package = "MRARegress")
devtools::use_vignette("MRARegress")
browseVignettes("MRARegress")
devtools::build()
devtools::install(build_vignettes=TRUE)
library(htmltools)
install.packages("htmltools")
install.packages("htmltools")
install.packages("htmltools")
install.packages("htmltools")
library(htmltools)
remove.packages("htmltools")
install.packages("htmltools")
?MRARegress
library(MRARegress)
?MRARegress
library(MRARegress)
?MRARegress
