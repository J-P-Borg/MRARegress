MatrCc[iNode, col]	<- (fELASTIC(MatU0, MatY0, Hyp_Lbda, 1, nbN))[2:nbN]
}
else if (Method == "RIDGE") {
MatrCc[iNode, col]	<- (fELASTIC(MatU0, MatY0, Hyp_Lbda, 0, nbN))[2:nbN]
}
else if (Method == "Elastic Net") {
MatrCc[iNode, col]	<- (fELASTIC(MatU0, MatY0, Hyp_Lbda, Hyp_Mu, nbN))[2:nbN]
}
else if (Method == "STEP") {
MatrCc[iNode, col]	<- fSTEP(MatU0, MatY0, Hyp_Step, nbN, Verbose)
}
else if (Method == "Random Forest") {
MatrCc[iNode, col]	<- fRForest(MatU0, MatY0, seqLetters, nbN-1)
}
else if (Method == "Order2") {
for (iCol2 in 1:(nbN-1)) {
MatV[ ,iCol2]		<- MatU[ ,iCol2]				# Linear terms			vs MatU0
MatV[ ,iCol2+nbN-1]	<- MatU[ ,iCol2]^2				# Quadratic terms
}	# iCol2
ind	<- 2*(nbN-1) +1
for (ind1 in 1:(nbN-2)) {
for (ind2 in (ind1+1):(nbN-1)) {
MatV[ ,ind]		<- MatU[ ,ind1]*MatU[ ,ind2]	# Product terms
ind	<- ind+1
}
}
MatV0	<- MatV
MatV0	<- MatV0[-row, ]
if (qr(MatV0)$rank < (nbN-1)*(2+(nbN-2)/2)) {
message ("The rank of the system is not sufficient with this method !")
cat ("Rank : ", qr(MatV0)$rank, " Needs :", (nbN-1)*(2+(nbN-2)/2), "\n")
return (toReturn)
}
if (Verbose) {
cat ("iNode ", iNode, "MatY0 \n")
print (MatY0)
cat ("MatV0 \n")
print (MatV0)
}
Form	<- "MatY0~MatV0+0"
MatrCc[iNode,col]	<- ((lm(as.formula(Form)))$coefficients)[1:(nbN-1)]
MatO2[iNode, ]		<- (lm(as.formula(Form)))$coefficients
MatO2[iNode,nbN:(2*(nbN-1))]	<-	2*MatO2[iNode,nbN:(2*(nbN-1))]		# To be consistent with Taylor's development
# (quadratic terms are multiplied by 0.5)
if (Verbose) {
cat("iNode ", iNode, " Coefficients ", 	(lm(as.formula(Form)))$coefficients, "\n")
}
}		# Order2
diag(MatrCc)	<- -1
if (Verbose) {
cat ("MatrCc iNode", iNode, "\n")
print (MatrCc[iNode, ])
}
# ANOVA
# 1/ Degrees of freedom
Anovas["SSR","df",iNode]	<- nbN-1			# Mason notation : p
idPerts	<- which(PerturbN[ ,2] == iNode)		# Id of the perturbations acting on this node, including replicates
nbPerts	<- length(idPerts)						# Nbr. of perturbations acting on this node.
nbRowsY0<- length(MatY0)						# Nbr. of equations for this node. Mason notation : n
Anovas["SSE","df",iNode]	<- nbRowsY0-nbN+1	# Mason notation : n-p
Meas	<- setdiff(PerturbR1, PerturbN[idPerts, 1]) # Equations acting on this node, excluding replicates.
nbMeas	<- length(Meas)							# Nbr. of perturbations acting on this node, excluding replicates. Mason notation : m
Anovas["Pure","df",iNode]	<- nbRowsY0-nbMeas 	# Mason notation : fp = n-m
Anovas["LOF","df",iNode]	<- nbMeas-nbN+1		# Mason notation :n-p-fp = m-p
Anovas["TSS","df",iNode]	<- nbRowsY0			# Mason notation : n
if ((Anovas["SSR","df",iNode]==0) || (Anovas["SSE","df",iNode]==0))
bSSR	<- FALSE
if ((Anovas["LOF","df",iNode]==0) || (Anovas["Pure","df",iNode]==0))
bLOF	<- FALSE
# 2/ Sums
ZMean	<- mean(MatY0)							# Mason notation : Zmean
ZEst	<- MatY0								# To define this vector. Mason notation : Zhat
ZEst[ ]	<- 0
for (j in 1:(nbN-1)) {
if (is.matrix(MatU0)) {
ZEst[ ]	<- ZEst[ ] + MatrCc[iNode,col[j]]*MatU0[ ,j]
} else {
ZEst[ ]	<- ZEst[ ] + MatrCc[iNode,col[j]]*MatU0[ ]
}
}
Anovas["SSR","Sum",iNode]	<- sum(sapply(ZEst-ZMean, fcarre))		# df=p
Anovas["SSE","Sum",iNode]	<- sum(sapply(MatY0-ZEst, fcarre))		# df=n-p
ZIMes	<- vector(length=nbMeas)				# Sum (yij - yi moy)^2
names(ZIMes)	<- Meas
for (Mes in Meas) {								# Name of one perturbation acting on this node, excluding replicas
iPert	<- which(PerturbR1 == Mes)
idPert	<- PerturbR2[[iPert]]				# Id of these perturbations in MatD
ZMes	<- MatD[idPert,iNode]				# Measures of these perturbations. Mason notation : yij
ZMesMean	<- mean(ZMes)
ZIMes[Mes]	<- sum(sapply(ZMes-ZMesMean, fcarre))
}
Anovas["Pure","Sum",iNode]	<- sum(ZIMes[ ])
Anovas["LOF","Sum",iNode]	<- Anovas["SSE","Sum",iNode] - Anovas["Pure","Sum",iNode]
Anovas["TSS","Sum",iNode]	<- sum(sapply(MatY0-ZMean, fcarre))		# df=n
# 3/ Means
Anovas[ ,"Mean",iNode]	<- Anovas[ ,"Sum",iNode] / Anovas[ ,"df",iNode]
# 4/ F  (Fisher/Snedecor) and pVal
Anovas["SSR","F",iNode]	<- Anovas["SSR","Mean",iNode] / Anovas["SSE","Mean",iNode]
if ((Anovas["SSR","df",iNode]>0) && (Anovas["SSE","df",iNode]>0))
Anovas["SSR","pVal",iNode]	<- 	pf(Anovas["SSR","F",iNode], Anovas["SSR","df",iNode], Anovas["SSE","df",iNode], lower.tail=FALSE)
else
bSSR	<- FALSE
Anovas["LOF","F",iNode]	<- Anovas["LOF","Mean",iNode] / Anovas["Pure","Mean",iNode]
if ((Anovas["LOF","df",iNode]>0) && (Anovas["Pure","df",iNode]>0))
Anovas["LOF","pVal",iNode]	<- 	pf(Anovas["LOF","F",iNode], Anovas["LOF","df",iNode], Anovas["Pure","df",iNode], lower.tail=FALSE)
else
bLOF	<- FALSE
# 5/ Results
if (Verbose) {
cat ("iNode", iNode, "p", nbN-1, "n", nbRowsY0, "m", nbMeas, " Anovas \n")
print (Anovas[ , ,iNode])
}
}		# for iNode
}			# else ARACNE ...
# Results of ANOVA
Anova["SSR", "df/m"]	<-	min(Anovas["SSR", "df", ])
Anova["SSR", "df/M"]	<-	max(Anovas["SSR", "df", ])
Anova["SSR", "Sum/m"]	<-	min(Anovas["SSR", "Sum", ])
Anova["SSR", "Sum/M"]	<-	max(Anovas["SSR", "Sum", ])
Anova["SSR", "Mean/m"]	<-	min(Anovas["SSR", "Mean", ])
Anova["SSR", "Mean/M"]	<-	max(Anovas["SSR", "Mean", ])
Anova["SSR", "F/m"]		<-	min(Anovas["SSR", "F", ])
Anova["SSR", "F/M"]		<-	max(Anovas["SSR", "F", ])
Anova["SSR", "pVal/m"]	<-	min(Anovas["SSR", "pVal", ])
Anova["SSR", "pVal/M"]	<-	max(Anovas["SSR", "pVal", ])
Anova["SSR", "nbrNdes"]	<-	length(which(Anova["SSR", "pVal/M"] > tlrSSR))
Anova["SSE", "df/m"]	<-	min(Anovas["SSE", "df", ])
Anova["SSE", "df/M"]	<-	max(Anovas["SSE", "df", ])
Anova["SSE", "Sum/m"]	<-	min(Anovas["SSE", "Sum", ])
Anova["SSE", "Sum/M"]	<-	max(Anovas["SSE", "Sum", ])
Anova["SSE", "Mean/m"]	<-	min(Anovas["SSE", "Mean", ])
Anova["SSE", "Mean/M"]	<-	max(Anovas["SSE", "Mean", ])
Anova["SSE", "F/m"]		<-	min(Anovas["SSE", "F", ])
Anova["SSE", "F/M"]		<-	max(Anovas["SSE", "F", ])
Anova["SSE", "pVal/m"]	<-	min(Anovas["SSE", "pVal", ])
Anova["SSE", "pVal/M"]	<-	max(Anovas["SSE", "pVal", ])
Anova["LOF", "df/m"]	<-	min(Anovas["LOF", "df", ])
Anova["LOF", "df/M"]	<-	max(Anovas["LOF", "df", ])
Anova["LOF", "Sum/m"]	<-	min(Anovas["LOF", "Sum", ])
Anova["LOF", "Sum/M"]	<-	max(Anovas["LOF", "Sum", ])
Anova["LOF", "Mean/m"]	<-	min(Anovas["LOF", "Mean", ])
Anova["LOF", "Mean/M"]	<-	max(Anovas["LOF", "Mean", ])
Anova["LOF", "F/m"]		<-	min(Anovas["LOF", "F", ])
Anova["LOF", "F/M"]		<-	max(Anovas["LOF", "F", ])
Anova["LOF", "pVal/m"]	<-	min(Anovas["LOF", "pVal", ], na.rm=TRUE)
Anova["LOF", "pVal/M"]	<-	max(Anovas["LOF", "pVal", ], na.rm=TRUE)
Anova["LOF", "nbrNdes"]	<-	length(which(Anova["LOF", "pVal/M"] > tlrLOF))
Anova["Pure", "df/m"]	<-	min(Anovas["Pure", "df", ])
Anova["Pure", "df/M"]	<-	max(Anovas["Pure", "df", ])
Anova["Pure", "Sum/m"]	<-	min(Anovas["Pure", "Sum", ])
Anova["Pure", "Sum/M"]	<-	max(Anovas["Pure", "Sum", ])
Anova["Pure", "Mean/m"]	<-	min(Anovas["Pure", "Mean", ])
Anova["Pure", "Mean/M"]	<-	max(Anovas["Pure", "Mean", ])
Anova["Pure", "F/m"]	<-	min(Anovas["Pure", "F", ])
Anova["Pure", "F/M"]	<-	max(Anovas["Pure", "F", ])
Anova["Pure", "pVal/m"]	<-	min(Anovas["Pure", "pVal", ], na.rm=TRUE)
Anova["Pure", "pVal/M"]	<-	max(Anovas["Pure", "pVal", ], na.rm=TRUE)
Anova["TSS", "df/m"]	<-	min(Anovas["TSS", "df", ])
Anova["TSS", "df/M"]	<-	max(Anovas["TSS", "df", ])
Anova["TSS", "Sum/m"]	<-	min(Anovas["TSS", "Sum", ])
Anova["TSS", "Sum/M"]	<-	max(Anovas["TSS", "Sum", ])
if (! bSSR) {
strSSR	<-	"Unable to compute SSR\n"
} else if (Anova["SSR", "nbrNdes"] > 0) {
strSSR	<- paste("The error is NOT explained by the regression used for ", Anova["SSR", "nbrNdes"], " nodes out of ", nbN, "!\n")
} else {
strSSR	<-	"Measures are explained by the model, at least partially !\n"
}
if (! bLOF) {
strLOF	<-	"Unable to compute LOF\n"
} else if (Anova["LOF", "nbrNdes"] > 0) {
strLOF	<- paste("Residual errors correspond to the noise level of the measurements for ", Anova["LOF", "nbrNdes"], " nodes out of ", nbN, "!\n")
} else {
strLOF	<-	"Residual errors are NOT explained by the noise level !\n"
}
AnovaOut	<- list(Anova, strSSR, strLOF)
cat ("DONE !", as.character(Sys.time()), "\n")
toReturn$r		<- MatrCc
toReturn$Order2	<- MatO2
toReturn$ANOVA	<- AnovaOut
toReturn$Input	<- Input
return (toReturn)
},		# expr
warning = function (e) {
message ("Warning detected !")
print(e)
toReturn$r		<- MatrCc
toReturn$Order2	<- MatO2
toReturn$ANOVA	<- AnovaOut
toReturn$Input	<- Input
return (toReturn)
},		# warning
error = function (e) {
message ("Error detected !")
print(e)
}		# error
)			# tryCatch
return (toReturn)
}		# MRARegress
#' Checks the input data for function MRARegress
#'
#' This function checks the input data for function MRARegress.
#' The parameters are same as those of MRARegress.
#'
#'@param MatExp		The "Expression Matrix".
#'@param Perturb	Refers to the name of the perturbations and the nodes they act upon.
#'@param NodeName	The name of the nodes.
#'@param KnlgMap	The "Knowledge Map".
#'@param Method		The method used to compute the connectivity matrix.
#'@param Hyp_Lbda	Hyper parameter needed by the LASSO, RIDGE, Elastic Net methods.
#'@param Hyp_Mu		Hyper parameter μ of the method 'Elastic Net'
#'@param Hyp_Step	Hyper parameter μ of the method 'Step'
#'@param Hyp_Eps	Hyper parameter ε of the method 'aracne'
#'@param Hyp_Cvx	Hyper parameter used by KnlgMap
#'@param MapExper	The "Experience Map" matrix
#'@param ParNode	The "Parameters /Nodes relation" matrix
#'@param Relative	"Relative or absolute" values for the Global Response Matrix ("R")
#'@param Verbose	If TRUE, additional printings are made. These printings are for internal use only, so they are not documented.
#'
#'
#' @return 			A message if an error is detected and returns NULL otherwise.
#'
CheckInputData	<- function (MatExp, Perturb, NodeName, KnlgMap, Method, Hyp_Lbda, Hyp_Mu, Hyp_Step, Hyp_Eps, Hyp_Cvx, MapExper, ParNode, Relative, Verbose) {
# Variables declaration
nbN			<- dim(MatExp)[1]										# Number of nodes
nbBase		<- ifelse(is.null(Perturb), 1, sum(Perturb=="Base"))	# Number of basal columns
nbPc		<- dim(MatExp)[2] - nbBase								# Number of conducted perturbations
nbP			<- nbBase*nbPc											# Number of "perturbations" taken into account
# Test Input Variables
if (is.null(MapExper)) {
H6		<- TRUE
nbM		<- nbN													# Number of parameters
} else {
H6		<- FALSE
nbM		<- dim(MapExper)[1]										# Number of parameters
}
# nbN, nbBase, nbPc, nbM
if (nbN < 2)
return ("Insufficient number of nodes !")
if (nbBase < 1)
return ("Insufficient number of basal columns !")
if (nbPc < 1)
return ("Insufficient number of perturbations !")
if (nbM < 1)
return ("Insufficient number of parameters (rows of MapExper) !")
# MatExp
if (! is.matrix(MatExp))
return ("MatExp must be a matrix !")
if (! is.numeric(MatExp))
return ("MatExp must contain numbers only !")
# Perturb
if (is.null(Perturb) && (nbP != nbN) && is.null(MapExper))
return ("Perturb is NULL and nb. perturbations != nb. nodes !")
if (! is.null(Perturb)) {
if (! is.vector(Perturb))
return ("Perturb must be NULL or a vector !")
if (length(Perturb) != dim(MatExp)[2])
return ("Perturb must be NULL or have as many columns as MatExp !")
if (nbBase <= 0)
return ("Perturb must contain one basal column at least !")
if (! is.null(MapExper) && (nbBase > 1))
return ("Perturb must contain exactly one basal column if MapExper is NOT NULL !")
}
# NodeName
if (! is.null(NodeName)) {
if (! is.vector(NodeName))
return ("NodeName must be NULL or a vector !")
if (length(NodeName) != nbN)
return ("NodeName must be NULL or have as many rows as MatExp !")
if (! is.character(NodeName))
return ("NodeName must be NULL or contain strings only !")
if (any(duplicated(NodeName)))
return ("Many nodes have the same name !")
}
# KnlgMap
if (! is.null(KnlgMap)) {
if (! is.matrix(KnlgMap))
return ("KnlgMap must be NULL or a matrix !")
if (dim(KnlgMap)[1] != dim(KnlgMap)[2])
return ("KnlgMap must be NULL or a square matrix !")
if (dim(KnlgMap)[1] != nbN)
return ("KnlgMap must be NULL or have as many rows as MatExp !")
if (sum(! (KnlgMap %in% c(0, 1, -1, "0", "1", "-1", "x"))) > 0 )
return ("KnlgMap must contain '0', '1', '-1' or 'x' only !")
if (Method != "TLR")
return ("KnlgMap works only with 'TLR' method !")
}
# Method
if (! is.character(Method))
return ("Method must be a string !")
if (! (Method %in% c("TLR", "LASSO", "RIDGE", "Elastic Net", "STEP", "ARACNE", "CLR", "MRNET", "Random Forest", "Order2")))
return ("Unknown method !")
# Hyper parameters
if (! is.null(Hyp_Lbda)) {
if (! is.numeric(Hyp_Lbda))
return ("Hyper parameter Hyp_Lbda must be NULL or a number !")
if (Hyp_Lbda < 0)
return ("Hyper parameter Hyp_Lbda must be NULL or a positive number !")
}
if (! is.numeric(Hyp_Mu))
return ("Hyper parameter Hyp_Mu must be NULL or a number !")
if (Hyp_Mu < 0)
return ("Hyper parameter Hyp_Mu must be NULL or a number between 0 and 1 !")
if (Hyp_Mu > 1)
return ("Hyper parameter Hyp_Mu must be NULL or a number between 0 and 1 !")
if (! (Hyp_Step %in% c("Fo", "Ba", "Bo")))
return ("Unknown Hyper parameter Hyp_Step !")
if (! is.numeric(Hyp_Eps))
return ("Hyper parameter Hyp_Eps must be NULL or a number !")
if (Hyp_Eps < 0)
return ("Hyper parameter Hyp_Eps must be NULL or a positive number !")
if (! is.numeric(Hyp_Cvx))
return ("Hyper parameter Hyp_Cvx must be NULL or a number !")
if (Hyp_Cvx < 0)
return ("Hyper parameter Hyp_Cvx must be NULL or a positive number !")
# MapExper
if (! is.null(MapExper)) {
if (! is.matrix(MapExper))
return ("MapExper must be NULL or a matrix !")
if (dim(MapExper)[2] != nbPc)
return ("MapExper must be NULL or have as many columns as the number of conducted perturbations !")
}
# ParNode
if (! is.null(ParNode)) {
if (! is.matrix(ParNode))
return ("ParNode must be NULL or a matrix !")
if (dim(ParNode)[1] != nbN || dim(ParNode)[2] != nbM)
return ("ParNode must be NULL or have as many rows as the number of nodes and as many columns as the number parameters !")
}
# Relative
if (! (Relative %in% c("TRUE", "FALSE"))) {
return ("Relative must be TRUE or FALSE !")
}
# Verbose
if (! (Verbose %in% c("TRUE", "FALSE"))) {
return ("Verbose must be TRUE or FALSE !")
}
# Number of perturbations
if (nbP < nbN)
return ("Not enough perturbations to get result !")
if (! is.null(MapExper) && (nbP < (nbN-1+nbM)))
return ("Not enough perturbations to get result !")
return (NULL)			# No error detected
}		# CheckInputData
#' Computes the "Connectivity Matrix" using ELASTICNET, RIDGE or LASSO Method (library glmnet)
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param Lbda		Hyper parameter λ of the method  -- If Lbda = NULL, a "best value" of Lbda is computed directly
#'@param Mu			Hyper parameter μ of the method  -- Mu = 0 : RIDGE, Mu = 1 : LASSO, else (between 0 and 1) : Elastic Net.
#'@param nbN		Number of nodes
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise (vector, length = nbN)
#'
fELASTIC	<- function (MatU, MatY, Lbda, Mu, nbN) {
tryCatch (
expr = {
rL 			<- vector(length=nbN)													# Result of Lasso method (ie sol. of Yi = Ai * Ui)
if (is.null(Lbda)) {
cv_model 	<- cv.glmnet(MatU, MatY, alpha = Mu, grouped = FALSE)				# Fits lasso regression model using k-fold cross-validation
Lbda		<- cv_model$lambda.min
}
best_model 	<- glmnet(MatU, MatY, alpha = Mu, lambda = Lbda, grouped = FALSE) 		# View coefficients of best model
rL			<-	coef(best_model)
return (rL)
},		# expr
error = function (e) {
message ("Error detected in ELASTIC method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fELASTIC
#' Computes the "Connectivity Matrix" using STEP Method
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param Meth		Hyper parameter of the method  -- "Fo" => "STEP-Fo", "Ba" => "STEP-Ba", "Bo" => "STEP-Bo"
#'@param nbN		Number of nodes
#'@param Verbose	Logical. If TRUE, additional printings are made. These printings are for internal use only, so they are not documented.
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise  (vector, length = nbN-1)
#'
fSTEP	<- function (MatU, MatY, Meth, nbN, Verbose) {
tryCatch (
expr = {
rij 		<- matrix(nrow=1, ncol=nbN-1)			# Intermediate calculation of rij - Use a matrix instead of a vector to use 'colnames'
Donnees  <- data.frame(MatY, MatU)
if (Verbose) {
cat(" Data ", colnames(Donnees), "\n")
}
Donnees	 <- rename(Donnees, "Y" ="MatY")			# The follow-up is clearer like this
cc 		 <- colnames(Donnees)						# Name of the columns "Data". The first one is "Y"
cc		 <- cc[-1]									# It remains the name of the coefficients ("X1", "X2", ... "Xn"  -- n = nbN-1)
colnames(rij) <- cc									# STEP gives the column names corresponding to the coefficients that are kept
switch(Meth,
"Fo" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(intercept_only, direction='forward', scope=formula(all), trace=0)},	# Forward
"Ba" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(all, direction='backward', scope=formula(all), trace=0)},				# Backward
"Bo" =
{intercept_only <- lm(Y ~ 1, data=Donnees)
all 	<- lm(Y ~ ., data=Donnees)
forward <- step(intercept_only, direction='both', scope=formula(all), trace=0)},		# Both
)
ll  	<- length(forward$coefficients)				# Number of coefficients kept by step
nn		<- names(forward$coefficients)				# Name of these coefficients
rij[1, ]	<- 0
if (ll >= 2) {
for (i in 2:ll) {								# nn[1] = "(Intercept)"
rij[1, nn[i]] <- forward$coefficients[nn[i]]
}
}
if (Verbose) {
cat (" ll ", ll, " nn ", nn, " rij ", rij, "\n")
}
return(rij[1, ])
},		# expr
error = function (e) {
message ("Error detected in STEP method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fSTEP
#' Computes the "Connectivity Matrix" using Random Forest Method (library randomForest)
#'
#'@param MatU		Used to compute linear Regression
#'@param MatY		Y as a function of U
#'@param seqLetters	A sequence of lower case letters "a", "b" .... used to name the columns
#'@param nbN		Number of nodes
#'
#'
#' @return 			NULL if an error is detected or the result ("r[iNode, ]") otherwise  (vector, length = nbN-1)
#'
fRForest	<- function (MatU, MatY, seqLetters, nbN) {
tryCatch (
expr = {
rL 			<- vector(length=nbN-1)					# Result of Random Forest method
nbLmin		<- 80									# minimum number of rows to use Random Forest method
MatA		<- cbind(MatY, MatU)
nr			<- nrow(MatA)
nrep		<- round(nbLmin/nr)
MatB		<- MatA
for (i in 1:nrep) {									# to have enough rows
MatB	<- rbind(MatB, MatA)
}
colnames(MatB)	<- c("Y", seqLetters)
rf			<- randomForest(Y ~ ., data=MatB, importance=TRUE)
rL			<- importance(rf)[,1]/sum(importance(rf)[,1])
return (rL)
},		# expr
error = function (e) {
message ("Error detected in Random Forest method !")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# fRForest
#' Computes a sequence of letters : "a", "b", "c", ...., "z", "aa", "ab", .... , "az", "ba", "bb" etc ....
#'
#'@param	n		The number of elements of the sequence
#'
#'
#' @return			A vector, length n, containing the sequence of letters
#'
sequence_letters <- function(n) {
tryCatch (
expr = {
seq <- character(n)
letters <- c(letters, "")
for (i in 1:n) {
indices <- c()
k <- i - 1
while (k >= 0) {
indices <- c((k %% 26) + 1, indices)
k <- k %/% 26 - 1
}
seq[i] <- paste0(letters[indices], collapse = "")
}
return(seq)
},		# expr
error = function (e) {
message ("Error detected in sequence_letters function!")
print(e)
}		# error
)			# tryCatch
return (NULL)
}		# sequence_letters
#' Computes a squared value
#'
#'@param	x		The value to square (may be a vector)
#'
#'
#' @return			A vector, with the values squared
#'
fcarre	= function(x) {x^2}
test_that("Order1 - Thomaseth 3 nodes network Plan Expé Patrice", {
expect_equal (MRARegress(MExpPat_10, MapExper=ExperPat, Relative=FALSE)$r, Pat3nds_O1, tolerance=1E-2)
})
test_that("Order2 - Thomaseth 3 nodes network Plan Expé Patrice", {
expect_equal (MRARegress(MExpPat_10, MapExper=ExperPat, Method="Order2", Relative=FALSE)$r, Pat3nds_O1, tolerance=1E-3)
})
test_that("Order2 - Thomaseth 3 nodes network Plan Expé Patrice", {
expect_equal (MRARegress(MExpPat_10, MapExper=ExperPat, Method="Order2", Relative=FALSE)$Order2, Pat3nds_O2, tolerance=1E-4)
})
